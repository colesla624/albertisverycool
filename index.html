<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Builder Game - Vertex Colors (V13)</title>
    <!-- Load Tailwind CSS for easy UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom CSS for the canvas and overall layout */
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Prevents default browser touch actions */
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }

        /* Action button refinement */
        .action-btn {
            @apply shadow-2xl transition transform active:scale-95 text-white font-bold rounded-full;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
            -webkit-tap-highlight-color: transparent;
        }

        /* Fixed Joystick Base Styles */
        #joystick-base {
            position: absolute;
            bottom: 30px; 
            left: 30px; 
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            z-index: 50;
            opacity: 0.8; 
        }

        /* Joystick Handle Styles (will move) */
        #joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            z-index: 60;
            opacity: 0; 
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 3D Canvas will be injected here -->
        <div id="crosshair"></div>

        <!-- Inventory/HUD -->
        <div id="hud" class="absolute top-4 left-1/2 transform -translate-x-1/2 p-2 bg-gray-900 bg-opacity-70 rounded-xl shadow-lg z-20 flex space-x-4">
            <div id="active-block" class="p-2 border-2 border-green-400 rounded-lg text-white font-bold cursor-pointer hover:bg-gray-700 transition">
                Active: Glass
            </div>
            <div id="action-tip" class="p-2 text-sm text-gray-300 hidden sm:block">
                WASD/Arrows to Move | Click to Lock Mouse & Look | Right-Click to Place
            </div>
        </div>
        
        <!-- View Toggle Button -->
        <button id="view-toggle-btn" class="absolute top-4 right-4 action-btn bg-purple-500 hover:bg-purple-600 active:bg-purple-700 p-3 text-sm z-30 w-32 h-12">
            Toggle View (FP)
        </button>


        <!-- Fixed Joystick Base (Mobile) -->
        <div id="joystick-base"></div>
        <!-- Dynamic Joystick Handle (Mobile) -->
        <div id="joystick-handle"></div>

        <!-- Mobile Action Buttons (Right Side) -->
        <div id="action-buttons" class="absolute bottom-6 right-6 flex flex-col space-y-4 z-20">
            <!-- Jump Button -->
            <button id="jump-btn" class="action-btn w-16 h-16 bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-3xl">
                â†‘
            </button>
            <!-- Place Block -->
            <button id="place-btn" class="action-btn w-16 h-16 bg-green-500 hover:bg-green-600 active:bg-green-700 text-4xl">
                +
            </button>
            <!-- Mine Block -->
            <button id="mine-btn" class="action-btn w-16 h-16 bg-red-500 hover:bg-red-600 active:bg-red-700 text-4xl">
                -
            </button>
        </div>
        
        <!-- Loading Spinner is no longer needed but kept for potential future use -->
        <div id="loading" class="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-90 z-50">
            <p class="absolute text-white">Initializing World...</p>
        </div>

    </div>

    <script type="module">
        // --- Core Global Variables ---
        let scene, camera, renderer;
        let playerModel; 
        let opaqueMesh; 
        let transparentGroup; 
        let cameraY; 
        
        // --- Materials (defined immediately, no texture loading needed) ---

        // Opaque Material uses vertexColors: true to read color data from geometry
        const OPAQUE_MATERIAL = new THREE.MeshStandardMaterial({
            vertexColors: true, 
            metalness: 0.1,
            roughness: 0.8,
        });

        // Dedicated Glass Material (transparent and non-textured)
        const GLASS_MATERIAL = new THREE.MeshStandardMaterial({
            color: 0x99FFFF, // Cyan-like color for glass
            transparent: true,
            opacity: 0.4,
            metalness: 0.1,
            roughness: 0.1,
        });
        
        // Block Definitions (using hex colors)
        const DIRT_COLOR = 0x6E3D27; // Updated deep brown color
        
        const blockTypes = {
            GRASS: { 
                name: 'Grass', 
                key: 'GRASS', 
                opaque: true, 
                // Bi-color definition for grass block
                colors: { 
                    TOP: 0x07A921,    // Vibrant forest green
                    SIDE: DIRT_COLOR, // Updated dirt color for sides
                    BOTTOM: DIRT_COLOR  // Updated dirt color for bottom
                } 
            },
            DIRT: { name: 'Dirt', key: 'DIRT', opaque: true, color: DIRT_COLOR },   // Uniform Deep Brown
            STONE: { name: 'Stone', key: 'STONE', opaque: true, color: 0x9E9E9E }, // Uniform Gray
            WOOD: { name: 'Wood', key: 'WOOD', opaque: true, color: 0x5D4037 },   // Uniform Dark Brown
            GLASS: { 
                name: 'Glass', 
                key: 'GLASS', 
                opaque: false, 
                color: 0x99FFFF // Cyan (used for HUD and transparent material)
            }
        };
        let activeBlockType = blockTypes.GLASS;
        
        // Block data storage: key -> blockType
        const worldBlockData = new Map(); 
        
        // --- Physics & Player Constants ---
        const GRAVITY = 0.0185;         
        const TERMINAL_VELOCITY = 0.5;  
        const JUMP_VELOCITY = 0.25;     
        const EPSILON = 0.0001; 
        
        // --- Movement Constants for Acceleration ---
        const MAX_WALK_SPEED = 0.115;    
        const ACCELERATION = 0.008;      
        const FRICTION = 0.4;            
        
        // Player's velocity vector
        let velocity = new THREE.Vector3(0, 0, 0); 
        
        // Player Collision Box (AABB)
        const playerHeight = 1.8;
        const playerRadius = 0.3; 
        const playerYOffset = -1.7; 
        
        // Player state and constants
        const player = {
            position: new THREE.Vector3(0, 10, 0), 
            rotationY: 0, 
            onGround: false,
        };
        const lookSpeed = 0.003; 

        // World Generation Constants
        const WORLD_SIZE = 64; 
        const MAX_HEIGHT = 16;
        
        // Standard block geometry (1 unit cube)
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        
        // Faces used for generating the merged mesh, including face index
        const CUBE_FACES = [
            { dir: [1, 0, 0], face: 0, normal: [1, 0, 0], side: 'SIDE' },  // Right
            { dir: [-1, 0, 0], face: 1, normal: [-1, 0, 0], side: 'SIDE' }, // Left
            { dir: [0, 1, 0], face: 2, normal: [0, 1, 0], side: 'TOP' },  // Top 
            { dir: [0, -1, 0], face: 3, normal: [0, -1, 0], side: 'BOTTOM' }, // Bottom
            { dir: [0, 0, 1], face: 4, normal: [0, 0, 1], side: 'SIDE' },  // Front
            { dir: [0, 0, -1], face: 5, normal: [0, 0, -1], side: 'SIDE' } // Back
        ];
        
        // --- Control Variables ---
        let controls = { forward: 0, backward: 0, left: 0, right: 0, up: false, down: false };
        let isThirdPerson = false;
        const thirdPersonDistance = 3.5; 
        const thirdPersonHeightOffset = 1.0; 
        const cameraLook = { yaw: 0, pitch: 0 };
        const joystick = { active: false, touchId: null, base: document.getElementById('joystick-base'), handle: document.getElementById('joystick-handle'), baseX: 0, baseY: 0, radius: 60, maxDistance: 40 };
        let activeLookTouch = null; 

        // --- Three.js Setup and Helpers ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 10);

        function getKey(x, y, z) {
            return `${x},${y},${z}`;
        }
        
        /**
         * Returns the block type object at the given integer coordinates, or null if empty.
         */
        function getBlockTypeAt(x, y, z) {
             return worldBlockData.get(getKey(Math.floor(x), Math.floor(y), Math.floor(z)));
        }

        function isBlockAt(x, y, z) {
            return worldBlockData.has(getKey(Math.floor(x), Math.floor(y), Math.floor(z)));
        }

        /**
         * Creates a flat-bottomed capsule (rounded cylinder) geometry for the player model.
         */
        function createCapsuleGeometry(radius, height, radialSegments) {
            const material = new THREE.MeshStandardMaterial({ color: 0x33AFFF });
            
            const cylinderHeightFlat = height - radius; 

            const cylinder = new THREE.CylinderGeometry(radius, radius, cylinderHeightFlat, radialSegments, 1);
            const cylinderMesh = new THREE.Mesh(cylinder, material);
            cylinderMesh.position.y = cylinderHeightFlat / 2; 

            const topSphere = new THREE.SphereGeometry(radius, radialSegments, radialSegments / 2);
            const topMesh = new THREE.Mesh(topSphere, material);
            topMesh.position.y = cylinderHeightFlat; 
            
            const group = new THREE.Group();
            group.add(cylinderMesh, topMesh);
            
            return group; 
        }

        /**
         * Creates and initializes the player visualization model.
         */
        function createPlayerModel() {
            playerModel = new THREE.Group();
            const capsuleVisual = createCapsuleGeometry(playerRadius, playerHeight, 16);
            
            playerModel.add(capsuleVisual);
            
            playerModel.position.copy(player.position);
            playerModel.visible = isThirdPerson; 
            scene.add(playerModel);
        }

        // --- World Generation and Optimization ---
        
        function getHeight(x, z) {
            const baseHeight = 4;
            const lowFreqNoise = Math.sin(x * 0.05) * 5 + Math.cos(z * 0.05) * 5;
            const highFreqNoise = Math.sin(x * 0.2) * 2 + Math.cos(z * 0.2) * 2;
            
            let height = Math.floor(baseHeight + lowFreqNoise + highFreqNoise); 
            height = Math.max(1, Math.min(MAX_HEIGHT, height)); 
            return height;
        }

        function populateWorldData() {
            worldBlockData.clear();
            const offset = Math.floor(WORLD_SIZE / 2);

            for (let x = -offset; x <= offset; x++) {
                for (let z = -offset; z <= offset; z++) {
                    
                    const groundHeight = getHeight(x, z); 
                    
                    for (let y = 0; y < groundHeight; y++) {
                        let type;
                        if (y === groundHeight - 1) {
                            type = blockTypes.GRASS; 
                        } else if (y >= groundHeight - 4) {
                            type = blockTypes.DIRT; 
                        } else {
                            type = blockTypes.STONE; 
                        }
                        worldBlockData.set(getKey(x, y, z), type);
                    }
                }
            }
        }
        
        /**
         * Generates the opaque mesh (merged) and the transparent blocks (individual meshes).
         * Now uses vertex color attributes instead of UV coordinates.
         */
        function generateMeshes() {
            const positions = [];
            const normals = [];
            const colors = []; // Array for RGB values (vertex colors)
            const transparentBlocks = new THREE.Group();

            const tempBoxGeometry = blockGeometry.clone();

            // BoxGeometry index buffer is organized into 6 faces, 6 vertices each (2 triangles)
            const indexAttribute = tempBoxGeometry.index;

            worldBlockData.forEach((type, key) => {
                const [x, y, z] = key.split(',').map(Number);
                
                if (type.opaque) {
                    
                    // Add to Opaque Mesh (with Culling)
                    CUBE_FACES.forEach(face => {
                        const nx = x + face.dir[0];
                        const ny = y + face.dir[1];
                        const nz = z + face.dir[2];

                        const neighborType = getBlockTypeAt(nx, ny, nz);

                        // Only render face if neighbor is air (null) or transparent (not opaque)
                        if (!neighborType || !neighborType.opaque) {
                            
                            // 1. Determine the color for this face
                            let faceColorHex;
                            if (type.key === 'GRASS') {
                                faceColorHex = type.colors[face.side];
                            } else {
                                faceColorHex = type.color;
                            }
                            const tempColor = new THREE.Color(faceColorHex);

                            tempBoxGeometry.translate(x + 0.5, y + 0.5, z + 0.5);
                            
                            const positionAttribute = tempBoxGeometry.attributes.position;
                            const startIndex = face.face * 6; // index for the 6 vertices of this face (2 triangles)
                            
                            for (let i = 0; i < 6; i++) {
                                const vertexIndex = indexAttribute.getX(startIndex + i);
                                
                                // 1. Positions
                                positions.push(positionAttribute.getX(vertexIndex), positionAttribute.getY(vertexIndex), positionAttribute.getZ(vertexIndex));
                                
                                // 2. Normals
                                normals.push(face.normal[0], face.normal[1], face.normal[2]);
                                
                                // 3. Colors (NEW!)
                                colors.push(tempColor.r, tempColor.g, tempColor.b); 
                            }

                            tempBoxGeometry.translate(-(x + 0.5), -(y + 0.5), -(z + 0.5));
                        }
                    });
                } else {
                    // Transparent Blocks (Individual Mesh)
                    const mesh = new THREE.Mesh(blockGeometry, GLASS_MATERIAL);
                    mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData.isWorld = true;
                    transparentBlocks.add(mesh);
                }
            });
            
            // Create the Opaque Mesh Geometry
            const opaqueGeometry = new THREE.BufferGeometry();
            opaqueGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            opaqueGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); 
            opaqueGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); // Add color attribute

            const mesh = new THREE.Mesh(opaqueGeometry, OPAQUE_MATERIAL);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.isWorld = true; 
            
            return { opaque: mesh, transparent: transparentBlocks };
        }

        function refreshWorldMesh() {
            // Remove old meshes/groups from scene
            if (opaqueMesh) {
                scene.remove(opaqueMesh);
                opaqueMesh.geometry.dispose();
            }
            if (transparentGroup) {
                scene.remove(transparentGroup);
            }

            // Generate new meshes
            const meshes = generateMeshes();

            // Assign and add to scene
            opaqueMesh = meshes.opaque;
            transparentGroup = meshes.transparent;
            
            scene.add(opaqueMesh);
            scene.add(transparentGroup);
        }
        
        // --- Collision and Movement Logic (No Change) ---
        
        function isColliding(newPos) {
            const minX = Math.floor(newPos.x - playerRadius);
            const maxX = Math.floor(newPos.x + playerRadius);
            
            const minY = Math.floor(newPos.y + playerYOffset);
            const maxY = Math.floor(newPos.y); 

            const minZ = Math.floor(newPos.z - playerRadius);
            const maxZ = Math.floor(newPos.z + playerRadius);

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        if (isBlockAt(x, y, z)) {
                            return true; 
                        }
                    }
                }
            }
            return false;
        }

        /**
         * Collision resolution.
         */
        function checkAndApplyMovement() {
            // 1. Apply gravity
            if (!player.onGround) {
                velocity.y = Math.max(-TERMINAL_VELOCITY, velocity.y - GRAVITY);
            }
            
            const delta = velocity.clone();

            player.onGround = false;

            // 2. Move X axis
            player.position.x += delta.x;
            if (isColliding(player.position)) {
                player.position.x -= delta.x; 
                velocity.x = 0;             
            }

            // 3. Move Y axis
            player.position.y += delta.y;
            if (isColliding(player.position)) {
                
                if (delta.y < 0) {
                    // Landing on floor: SNAP the position exactly to the top surface.
                    const minYBlock = Math.floor(player.position.y + playerYOffset);
                    
                    // Use EPSILON to push the player slightly above the block top (minYBlock + 1)
                    player.position.y = (minYBlock + 1) - playerYOffset + EPSILON; 
                    
                    player.onGround = true; 
                } else { 
                    // Hitting ceiling (delta.y >= 0): SNAP the player's head exactly to the bottom 
                    player.position.y = Math.floor(player.position.y); 
                }
                
                // Set velocity to zero for all Y-collisions
                velocity.y = 0;             
            }
            
            // 4. Move Z axis
            player.position.z += delta.z;
            if (isColliding(player.position)) {
                player.position.z -= delta.z; 
                velocity.z = 0;             
            }
        }
        
        // --- Block Manipulation (No Change) ---
        
        // Helper to check for intersection between the new block's AABB and the player's AABB
        function checkPlayerBlockOverlap(blockX, blockY, blockZ) {
            // Player AABB (based on head position player.position.y)
            const playerMinX = player.position.x - playerRadius;
            const playerMaxX = player.position.x + playerRadius;
            const playerMinY = player.position.y + playerYOffset; // Feet
            const playerMaxY = player.position.y;                   // Head/Camera
            const playerMinZ = player.position.z - playerRadius;
            const playerMaxZ = player.position.z + playerRadius;

            // New Block AABB
            const blockMinX = blockX;
            const blockMaxX = blockX + 1;
            const blockMinY = blockY;
            const blockMaxY = blockY + 1;
            const blockMinZ = blockZ;
            const blockMaxZ = blockZ + 1;

            // Check for overlap along all three axes (AABB intersection rule)
            const overlapX = (blockMaxX > playerMinX) && (blockMinX < playerMaxX);
            const overlapY = (blockMaxY > playerMinY) && (blockMinY < playerMaxY);
            const overlapZ = (blockMaxZ > playerMinZ) && (blockMinZ < playerMaxZ);

            return overlapX && overlapY && overlapZ;
        }

        // Raycast against both the opaque mesh and the transparent group
        function getTargetedBlock() {
            if (!opaqueMesh) return null;

            raycaster.setFromCamera({ x: 0, y: 0 }, camera); 
            
            // Intersect with both the single merged mesh and the group of transparent blocks
            const intersects = raycaster.intersectObjects([opaqueMesh, ...transparentGroup.children]);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                // Calculate block coordinates
                const x = Math.floor(intersect.point.x - intersect.face.normal.x * 0.01);
                const y = Math.floor(intersect.point.y - intersect.face.normal.y * 0.01);
                const z = Math.floor(intersect.point.z - intersect.face.normal.z * 0.01);

                const normal = intersect.face.normal.clone();

                return { x, y, z, normal };
            }
            return null;
        }
        
        function mineBlock() {
            const target = getTargetedBlock();
            if (target) {
                const key = getKey(target.x, target.y, target.z);
                
                if (worldBlockData.has(key)) {
                    worldBlockData.delete(key);
                    refreshWorldMesh(); 
                }
            }
        }

        function placeBlock() {
            const target = getTargetedBlock();
            if (target) {
                const newX = target.x + Math.round(target.normal.x);
                const newY = target.y + Math.round(target.normal.y);
                const newZ = target.z + Math.round(target.normal.z);

                const newBlockKey = getKey(newX, newY, newZ);
                
                // Use dedicated AABB intersection check to see if the new block overlaps with the player.
                if (checkPlayerBlockOverlap(newX, newY, newZ)) {
                    return; 
                }

                if (!worldBlockData.has(newBlockKey)) {
                    worldBlockData.set(newBlockKey, activeBlockType);
                    refreshWorldMesh(); 
                }
            }
        }

        
        // --- Initialization and Game Loop ---

        function init() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;
            const aspectRatio = containerWidth / containerHeight;
            const loadingScreen = document.getElementById('loading');
            
            // No texture loading needed, proceed directly to initialization
            loadingScreen.style.display = 'none';
            
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.copy(player.position); 

            // Initialize smoothed camera Y position
            cameraY = player.position.y; 

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement); 
            
            // IMPORTANT: Tell the renderer to sort transparent objects, essential for the glass fix.
            renderer.sortObjects = true;

            // 4. Lighting 
            const ambientLight = new THREE.AmbientLight(0x404040, 3); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; 
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // 5. World Generation
            populateWorldData(); 
            refreshWorldMesh(); 

            // 6. Player Model
            createPlayerModel();

            // 7. Event Listeners
            window.addEventListener('resize', () => { onWindowResize(); calculateJoystickPosition(); });
            setupInputListeners(container);
            calculateJoystickPosition(); 
            updateActiveBlockDisplay();

            // 8. Find a safe starting position above the generated terrain
            player.position.y = getHeight(0, 0) + playerHeight + 2; 

            // 9. Start the game loop
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. Calculate input force
            const horizontalInputActive = controls.forward > 0 || controls.backward > 0 || controls.left > 0 || controls.right > 0;
            
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const rightVector = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            rightVector.y = 0;
            rightVector.normalize();

            // 2. Set target velocity based on input (Applying Acceleration)
            if (horizontalInputActive) {
                const targetDirection = new THREE.Vector3();
                
                targetDirection.addScaledVector(cameraDirection, (controls.forward - controls.backward));
                targetDirection.addScaledVector(rightVector, (controls.right - controls.left));
                
                if (targetDirection.lengthSq() > 0) {
                    targetDirection.normalize();
                    
                    // Apply acceleration (always pushes velocity toward target direction)
                    velocity.x += targetDirection.x * ACCELERATION;
                    velocity.z += targetDirection.z * ACCELERATION;

                    // Cap speed at MAX_WALK_SPEED
                    const currentSpeedSq = velocity.x * velocity.x + velocity.z * velocity.z;
                    if (currentSpeedSq > MAX_WALK_SPEED * MAX_WALK_SPEED) {
                        const currentSpeed = Math.sqrt(currentSpeedSq);
                        const scaleFactor = MAX_WALK_SPEED / currentSpeed;
                        velocity.x *= scaleFactor;
                        velocity.z *= scaleFactor;
                    }
                }

            } else if (player.onGround) {
                // Apply friction for smooth deceleration when no keys are pressed
                velocity.x *= FRICTION;
                velocity.z *= FRICTION;
                
                // Stop completely when velocity is near zero
                if (Math.abs(velocity.x) < 0.005) velocity.x = 0;
                if (Math.abs(velocity.z) < 0.005) velocity.z = 0;
            }

            // 3. Handle Jump
            if (controls.up && player.onGround) {
                velocity.y = JUMP_VELOCITY;
                player.onGround = false;
                controls.up = false; 
            }

            // 4. Collision Detection and Movement Application
            checkAndApplyMovement();
            
            // 5. Smooth Camera Y Position 
            cameraY = THREE.MathUtils.lerp(cameraY, player.position.y, 0.3);


            // 6. Update Player Model position and rotation
            playerModel.position.copy(player.position);
            if (horizontalInputActive) {
                const horizontalVelocity = new THREE.Vector2(velocity.x, velocity.z);
                if (horizontalVelocity.lengthSq() > 0.001) { 
                    const angle = Math.atan2(horizontalVelocity.x, horizontalVelocity.y);
                    player.rotationY = angle;
                }
            }
            playerModel.rotation.y = player.rotationY; 

            // 7. Camera View Update
            if (isThirdPerson) {
                const radius = thirdPersonDistance;
                const pitch = cameraLook.pitch;
                const yaw = cameraLook.yaw;
                
                camera.position.x = player.position.x + radius * Math.sin(yaw) * Math.cos(pitch);
                camera.position.y = player.position.y + thirdPersonHeightOffset + radius * Math.sin(pitch);
                camera.position.z = player.position.z + radius * Math.cos(yaw) * Math.cos(pitch);
                
                camera.lookAt(player.position.x, player.position.y + thirdPersonHeightOffset, player.position.z);
                
            } else {
                // First Person (FP) View uses the smoothed cameraY
                camera.position.x = player.position.x;
                camera.position.z = player.position.z;
                camera.position.y = cameraY; 
                camera.rotation.set(cameraLook.pitch, cameraLook.yaw, 0, 'YXZ');
            }

            // 8. Rendering
            renderer.render(scene, camera);
        }

        // --- UI and Input Handlers (No Change) ---
        
        function toggleView() {
            isThirdPerson = !isThirdPerson;
            const button = document.getElementById('view-toggle-btn');
            const crosshair = document.getElementById('crosshair');
            
            playerModel.visible = isThirdPerson;
            
            if (isThirdPerson) {
                button.textContent = 'Toggle View (TP)';
                crosshair.style.display = 'none'; 
                player.rotationY = cameraLook.yaw; 
            } else {
                button.textContent = 'Toggle View (FP)';
                crosshair.style.display = 'block';
            }
        }
        
        function onWindowResize() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;

            camera.aspect = containerWidth / containerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(containerWidth, containerHeight);
        }

        function calculateJoystickPosition() {
            const rect = joystick.base.getBoundingClientRect();
            joystick.baseX = rect.left + joystick.radius;
            joystick.baseY = rect.top + joystick.radius;

            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;
        }

        function updateJoystick(currentX, currentY) {
            const dx = currentX - joystick.baseX;
            const dy = currentY - joystick.baseY;
            let distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let finalX = currentX;
            let finalY = currentY;

            if (distance > joystick.maxDistance) {
                distance = joystick.maxDistance;
                finalX = joystick.baseX + Math.cos(angle) * joystick.maxDistance;
                finalY = joystick.baseY + Math.sin(angle) * joystick.maxDistance;
            } else {
                finalX = currentX;
                finalY = currentY;
            }

            joystick.handle.style.left = `${finalX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${finalY - joystick.radius / 2}px`;

            const magnitude = distance / joystick.maxDistance; 
            const forwardComponent = -Math.sin(angle); 
            const rightComponent = Math.cos(angle); 

            controls.forward = Math.max(0, forwardComponent) * magnitude;
            controls.backward = Math.max(0, -forwardComponent) * magnitude;
            controls.right = Math.max(0, rightComponent) * magnitude;
            controls.left = Math.max(0, -rightComponent) * magnitude;
        }

        function resetJoystick() {
            joystick.active = false;
            joystick.touchId = null;
            joystick.handle.style.opacity = '0';
            
            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;

            controls.forward = controls.backward = controls.left = controls.right = 0;
        }

        function applyLookDelta(deltaX, deltaY, speed) {
            cameraLook.yaw -= deltaX * speed;
            // Standard vertical look (Up swipe = Up view)
            cameraLook.pitch -= deltaY * speed; 
            
            cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraLook.pitch));
        }

        function setupInputListeners(container) {
            const canvasElement = renderer.domElement;
            const containerWidth = container.clientWidth;

            // --- Keyboard Controls (Desktop) ---
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') controls.forward = 1;
                if (key === 's' || key === 'arrowdown') controls.backward = 1;
                if (key === 'a' || key === 'arrowleft') controls.left = 1;
                if (key === 'd' || key === 'arrowright') controls.right = 1;
                if (key === ' ') controls.up = true; 
                if (key === 'v') toggleView(); 
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') controls.forward = 0;
                if (key === 's' || key === 'arrowdown') controls.backward = 0;
                if (key === 'a' || key === 'arrowleft') controls.left = 0;
                if (key === 'd' || key === 'arrowright') controls.right = 0;
            });

            // --- Mouse/Look & Action Controls (Desktop) ---
            canvasElement.addEventListener('mousedown', (e) => {
                if (e.pointerType === 'mouse' || container.clientWidth > 768) { 
                    if (e.button === 0) {
                        mineBlock();
                        if (canvasElement.requestPointerLock) {
                            canvasElement.requestPointerLock();
                        }
                    } 
                    else if (e.button === 2) {
                        placeBlock(); 
                    }
                }
            });
            
            canvasElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvasElement) { 
                    applyLookDelta(e.movementX, e.movementY, lookSpeed);
                }
            });

            // --- Mobile Touch Controls (Joystick & Look Pad) ---
            
            const isInsideJoystickArea = (clientX, clientY) => {
                const dx = clientX - joystick.baseX;
                const dy = clientY - joystick.baseY;
                return Math.sqrt(dx * dx + dy * dy) <= joystick.radius;
            };

            container.addEventListener('touchstart', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (!joystick.active && isInsideJoystickArea(touch.clientX, touch.clientY)) {
                        joystick.active = true;
                        joystick.touchId = touch.identifier;
                        joystick.handle.style.opacity = '1';
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    else if (
                        touch.clientX >= containerWidth / 2 && 
                        !touch.target.closest('#action-buttons') && 
                        !activeLookTouch &&
                        !touch.target.closest('#view-toggle-btn')
                    ) {
                        activeLookTouch = {
                            identifier: touch.identifier,
                            prevX: touch.clientX,
                            prevY: touch.clientY
                        };
                    }
                }
            }, { passive: true }); 

            container.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        const deltaX = touch.clientX - activeLookTouch.prevX;
                        const deltaY = touch.clientY - activeLookTouch.prevY;
                        
                        applyLookDelta(deltaX, deltaY, lookSpeed * 5); 
                        
                        activeLookTouch.prevX = touch.clientX; 
                        activeLookTouch.prevY = touch.clientY;
                    }
                }
            }, { passive: false }); 

            container.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        resetJoystick();
                    }
                    
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        activeLookTouch = null;
                    }
                }
            }, { passive: true });
            
            // --- Mobile Action Button Listeners ---
            document.getElementById('mine-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                mineBlock();
            }, { passive: false });

            document.getElementById('place-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                placeBlock();
            }, { passive: false });
            
            document.getElementById('jump-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                controls.up = true; 
            }, { passive: false });
            document.getElementById('jump-btn').addEventListener('pointerup', (e) => {
                e.preventDefault();
                controls.up = false; 
            }, { passive: false });

            document.getElementById('view-toggle-btn').addEventListener('click', toggleView);

            document.getElementById('active-block').addEventListener('click', cycleActiveBlock);
        }

        function cycleActiveBlock() {
            const typesArray = Object.values(blockTypes);
            let currentIndex = typesArray.findIndex(type => type.name === activeBlockType.name);
            currentIndex = (currentIndex + 1) % typesArray.length;
            activeBlockType = typesArray[currentIndex];
            updateActiveBlockDisplay();
        }

        function updateActiveBlockDisplay() {
            const display = document.getElementById('active-block');
            display.textContent = `Active: ${activeBlockType.name}`;
            
            // Determine the color for the HUD display border
            let displayColor;
            if (activeBlockType.key === 'GRASS') displayColor = `#${new THREE.Color(activeBlockType.colors.TOP).getHexString()}`;
            else if (activeBlockType.key === 'GLASS') displayColor = `#${new THREE.Color(activeBlockType.color).getHexString()}`;
            else if (activeBlockType.color) displayColor = `#${new THREE.Color(activeBlockType.color).getHexString()}`;
            else displayColor = 'white';

            display.style.borderColor = displayColor;
        }


        // Start the application after the window loads
        window.onload = init;
    </script>
</body>
</html>
