<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Minecraft-like Prototype with Joystick, Terrain, POV, Build</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    body { margin: 0; overflow: hidden; font-family: system-ui, sans-serif; }
    canvas { display: block; }

    /* UI */
    .btn {
      position: absolute;
      padding: 8px 12px;
      background: rgba(20,20,20,0.6);
      color: white;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 6px;
      font-size: 14px;
      backdrop-filter: blur(4px);
      user-select: none;
      touch-action: manipulation;
    }
    #povBtn { top: 12px; left: 12px; }

    #uiRight {
      position: absolute;
      right: 16px;
      bottom: 120px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    #jumpBtn { position: absolute; right: 16px; bottom: 16px; }

    /* Joystick */
    #joystick {
      position: absolute;
      bottom: 30px;
      left: 30px;
      width: 140px;
      height: 140px;
      background: rgba(200,200,200,0.18);
      border: 2px solid rgba(255,255,255,0.25);
      border-radius: 50%;
      touch-action: none;
    }
    #stick {
      position: absolute;
      width: 64px;
      height: 64px;
      background: rgba(100,100,100,0.6);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      left: 38px;
      top: 38px;
      touch-action: none;
    }

    /* Crosshair */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 18px; height: 18px;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    #crosshair::before, #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.9);
    }
    #crosshair::before { width: 2px; height: 18px; left: 8px; top: 0; }
    #crosshair::after { width: 18px; height: 2px; left: 0; top: 8px; }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <button id="povBtn" class="btn">POV: Third</button>
  <div id="uiRight">
    <button id="placeBtn" class="btn">Place</button>
    <button id="deleteBtn" class="btn">Delete</button>
  </div>
  <button id="jumpBtn" class="btn">Jump</button>

  <div id="joystick">
    <div id="stick"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    // ------------------------------------------------------------
    // Basic helpers: seeded noise for terrain
    // ------------------------------------------------------------
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }
    // 2D value noise
    function makeNoise2D(seed = 12345) {
      const rand = mulberry32(seed);
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) perm[i] = i;
      // shuffle
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 256; i++) perm[256 + i] = perm[i];

      function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
      function lerp(a, b, t) { return a + t * (b - a); }
      function grad(hash, x, y) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
      }
      return function(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x), v = fade(y);
        const aa = perm[X + perm[Y]];
        const ab = perm[X + perm[Y + 1]];
        const ba = perm[X + 1 + perm[Y]];
        const bb = perm[X + 1 + perm[Y + 1]];
        return lerp(lerp(grad(aa, x, y), grad(ba, x - 1, y), u),
                    lerp(grad(ab, x, y - 1), grad(bb, x - 1, y - 1), u), v);
      };
    }

    // ------------------------------------------------------------
    // THREE setup
    // ------------------------------------------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 6, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x889988, 0.7);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(20, 30, 10);
    scene.add(dir);

    // ------------------------------------------------------------
    // Voxel world data
    // ------------------------------------------------------------
    const BLOCK_SIZE = 1;
    const WORLD_SIZE = 64; // width and depth
    const MAX_HEIGHT = 14;

    // Materials
    const matGrass = new THREE.MeshLambertMaterial({ color: 0x3a9d23 });
    const matDirt  = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
    const matStone = new THREE.MeshLambertMaterial({ color: 0x808080 });

    const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

    // Store blocks in a Map keyed by "x,y,z" and keep refs to meshes for raycast/collision
    const voxels = new Map();

    function key(x, y, z) { return `${x},${y},${z}`; }

    function addBlock(x, y, z, type = "grass") {
      const k = key(x, y, z);
      if (voxels.has(k)) return;
      const mat = type === "stone" ? matStone : (type === "dirt" ? matDirt : matGrass);
      const mesh = new THREE.Mesh(blockGeo, mat);
      mesh.position.set(x + BLOCK_SIZE/2, y + BLOCK_SIZE/2, z + BLOCK_SIZE/2);
      mesh.userData = { x, y, z, type: type };
      scene.add(mesh);
      voxels.set(k, mesh);
    }

    function removeBlock(x, y, z) {
      const k = key(x, y, z);
      const mesh = voxels.get(k);
      if (!mesh) return;
      scene.remove(mesh);
      mesh.geometry.dispose();
      // Do not dispose material to reuse shared materials
      voxels.delete(k);
    }

    // ------------------------------------------------------------
    // Random terrain generation with noise
    // ------------------------------------------------------------
    const noise = makeNoise2D(1337);
    const SCALE = 0.08;
    for (let x = 0; x < WORLD_SIZE; x++) {
      for (let z = 0; z < WORLD_SIZE; z++) {
        const nx = x * SCALE;
        const nz = z * SCALE;
        // combine low and mid frequency noise
        const h =
          (noise(nx, nz) * 0.7) +
          (noise(nx * 0.5, nz * 0.5) * 0.3);
        const height = Math.floor((h * 0.5 + 0.5) * MAX_HEIGHT); // normalize to [0,1], scale

        for (let y = 0; y <= height; y++) {
          const type = y === height ? "grass" : (y > height - 3 ? "dirt" : "stone");
          addBlock(x, y, z, type);
        }
      }
    }

    // ------------------------------------------------------------
    // Player setup (AABB approximation)
    // ------------------------------------------------------------
    const playerGeo = new THREE.BoxGeometry(0.8, 1.6, 0.8);
    const playerMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
    const player = new THREE.Mesh(playerGeo, playerMat);
    player.position.set(WORLD_SIZE/2 + 0.5, 20, WORLD_SIZE/2 + 0.5);
    scene.add(player);

    const playerVel = new THREE.Vector3(0, 0, 0);
    const GRAVITY = 18;
    const MOVE_SPEED = 4.0;
    const JUMP_SPEED = 7.5;
    let onGround = false;

    // POV: third or first
    let pov = "third";

    // ------------------------------------------------------------
    // Joystick
    // ------------------------------------------------------------
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");
    let joyCenter = null;
    let joyVec = { x: 0, y: 0 };
    const JOY_RADIUS = 52;

    function recalcJoyCenter() {
      const rect = joystick.getBoundingClientRect();
      joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    }
    recalcJoyCenter();
    window.addEventListener('resize', recalcJoyCenter);

    function updateJoystick(e) {
      const touch = e.touches[0];
      const dx = touch.clientX - joyCenter.x;
      const dy = touch.clientY - joyCenter.y;
      const dist = Math.min(Math.hypot(dx, dy), JOY_RADIUS);
      const angle = Math.atan2(dy, dx);
      joyVec.x = Math.cos(angle) * (dist / JOY_RADIUS);
      joyVec.y = Math.sin(angle) * (dist / JOY_RADIUS);
      stick.style.left = (38 + joyVec.x * JOY_RADIUS) + "px";
      stick.style.top  = (38 + joyVec.y * JOY_RADIUS) + "px";
    }

    joystick.addEventListener("touchstart", updateJoystick, { passive: true });
    joystick.addEventListener("touchmove", updateJoystick, { passive: true });
    joystick.addEventListener("touchend", () => {
      joyVec.x = 0; joyVec.y = 0;
      stick.style.left = "38px";
      stick.style.top  = "38px";
    });

    // ------------------------------------------------------------
    // Input buttons: POV, jump, place, delete
    // ------------------------------------------------------------
    const povBtn = document.getElementById("povBtn");
    const jumpBtn = document.getElementById("jumpBtn");
    const placeBtn = document.getElementById("placeBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    povBtn.addEventListener("click", () => {
      pov = (pov === "third") ? "first" : "third";
      povBtn.textContent = `POV: ${pov === "third" ? "Third" : "First"}`;
    });

    jumpBtn.addEventListener("click", () => {
      if (onGround) {
        playerVel.y = JUMP_SPEED;
        onGround = false;
      }
    });

    // ------------------------------------------------------------
    // Raycasting utilities for block interaction
    // ------------------------------------------------------------
    const raycaster = new THREE.Raycaster();

    function getCameraRayTarget() {
      // center of screen
      const mouse = new THREE.Vector2(0, 0);
      raycaster.setFromCamera(mouse, camera);

      // raycast against voxel meshes
      const meshes = Array.from(voxels.values());
      const hits = raycaster.intersectObjects(meshes, false);
      if (hits.length === 0) return null;
      return hits[0]; // closest
    }

    function placeBlockAtTarget() {
      const hit = getCameraRayTarget();
      if (!hit) return;
      const normal = hit.face.normal.clone().applyMatrix3(new THREE.Matrix3().setFromMatrix4(hit.object.matrixWorld));
      // place block adjacent in the face normal direction (normalized to grid)
      const gx = Math.floor(hit.point.x + normal.x * 0.5);
      const gy = Math.floor(hit.point.y + normal.y * 0.5);
      const gz = Math.floor(hit.point.z + normal.z * 0.5);
      if (gx < 0 || gz < 0 || gx >= WORLD_SIZE || gz >= WORLD_SIZE || gy < 0 || gy > MAX_HEIGHT + 8) return;
      addBlock(gx, gy, gz, "grass");
    }

    function deleteBlockAtTarget() {
      const hit = getCameraRayTarget();
      if (!hit) return;
      const { x, y, z } = hit.object.userData;
      removeBlock(x, y, z);
    }

    placeBtn.addEventListener("click", placeBlockAtTarget);
    deleteBtn.addEventListener("click", deleteBlockAtTarget);

    // ------------------------------------------------------------
    // Movement and collision
    // ------------------------------------------------------------
    function aabbIntersect(ax, ay, az, asx, asy, asz, bx, by, bz, bsx, bsy, bsz) {
      return Math.abs(ax - bx) * 2 < (asx + bsx) &&
             Math.abs(ay - by) * 2 < (asy + bsy) &&
             Math.abs(az - bz) * 2 < (asz + bsz);
    }

    function resolveCollisions() {
      // Player AABB
      const psx = 0.8, psy = 1.6, psz = 0.8;
      const px = player.position.x;
      const py = player.position.y;
      const pz = player.position.z;

      onGround = false;

      // Only check nearby blocks for efficiency
      const minX = Math.floor(px - 1.5);
      const maxX = Math.floor(px + 1.5);
      const minY = Math.floor(py - 1.0);
      const maxY = Math.floor(py + 1.0);
      const minZ = Math.floor(pz - 1.5);
      const maxZ = Math.floor(pz + 1.5);

      for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
          for (let z = minZ; z <= maxZ; z++) {
            const k = key(x, y, z);
            const mesh = voxels.get(k);
            if (!mesh) continue;
            const bx = mesh.position.x;
            const by = mesh.position.y;
            const bz = mesh.position.z;
            const bs = BLOCK_SIZE;

            if (aabbIntersect(px, py, pz, psx, psy, psz, bx, by, bz, bs, bs, bs)) {
              // Compute penetration along each axis (simple separation)
              const dx = (psx/2 + bs/2) - Math.abs(px - bx);
              const dy = (psy/2 + bs/2) - Math.abs(py - by);
              const dz = (psz/2 + bs/2) - Math.abs(pz - bz);

              if (dx < dy && dx < dz) {
                const sign = (px < bx) ? -1 : 1;
                player.position.x += sign * dx;
                playerVel.x = 0;
              } else if (dy < dx && dy < dz) {
                const sign = (py < by) ? -1 : 1;
                player.position.y += sign * dy;
                if (sign < 0) {
                  // collided from above -> standing on ground
                  onGround = true;
                }
                playerVel.y = Math.min(playerVel.y, 0);
              } else {
                const sign = (pz < bz) ? -1 : 1;
                player.position.z += sign * dz;
                playerVel.z = 0;
              }
            }
          }
        }
      }
    }

    // ------------------------------------------------------------
    // Camera follow logic (first-person / third-person)
    // ------------------------------------------------------------
    function updateCamera(dt) {
      const target = player.position.clone();
      if (pov === "first") {
        camera.position.copy(target).add(new THREE.Vector3(0, 0.6, 0));
        // Look direction derived from player forward; for now fixed forward
        const forward = new THREE.Vector3(0, 0, -1);
        const camTarget = target.clone().add(forward);
        camera.lookAt(camTarget);
      } else {
        // third-person: behind and above the player
        const offset = new THREE.Vector3(0, 4, 8);
        camera.position.copy(target).add(offset);
        camera.lookAt(target);
      }
    }

    // ------------------------------------------------------------
    // Animate
    // ------------------------------------------------------------
    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.033);
      lastTime = now;

      // Apply gravity
      playerVel.y -= GRAVITY * dt;

      // Movement from joystick
      // Map joystick x->strafe, y->forward (Z- forward)
      const forward = new THREE.Vector3(0, 0, -1);
      const right = new THREE.Vector3(1, 0, 0);

      const moveDir = new THREE.Vector3()
        .addScaledVector(right, joyVec.x)
        .addScaledVector(forward, joyVec.y);
      if (moveDir.lengthSq() > 0) moveDir.normalize();

      playerVel.x = moveDir.x * MOVE_SPEED;
      playerVel.z = moveDir.z * MOVE_SPEED;

      // Integrate velocity
      player.position.x += playerVel.x * dt;
      player.position.y += playerVel.y * dt;
      player.position.z += playerVel.z * dt;

      // Resolve collisions with nearby voxels
      resolveCollisions();

      // Keep player within world bounds
      player.position.x = Math.max(0.4, Math.min(WORLD_SIZE - 0.4, player.position.x));
      player.position.z = Math.max(0.4, Math.min(WORLD_SIZE - 0.4, player.position.z));
      // Hard floor at y=0
      if (player.position.y < 0.8) {
        player.position.y = 0.8;
        playerVel.y = 0;
        onGround = true;
      }

      updateCamera(dt);
      renderer.render(scene, camera);
    }
    animate();

    // ------------------------------------------------------------
    // Resize
    // ------------------------------------------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      recalcJoyCenter();
    });

    // ------------------------------------------------------------
    // Optional: desktop fallbacks (WASD + space)
    // ------------------------------------------------------------
    const keys = new Set();
    window.addEventListener('keydown', e => {
      keys.add(e.code);
      if (e.code === "Space") jumpBtn.click();
    });
    window.addEventListener('keyup', e => keys.delete(e.code));

    function desktopControlsToJoystick() {
      let x = 0, y = 0;
      if (keys.has("KeyA")) x -= 1;
      if (keys.has("KeyD")) x += 1;
      if (keys.has("KeyW")) y += 1;
      if (keys.has("KeyS")) y -= 1;
      const len = Math.hypot(x, y);
      if (len > 0) { x /= len; y /= len; }
      joyVec.x = x; joyVec.y = y;
      stick.style.left = (38 + joyVec.x * JOY_RADIUS) + "px";
      stick.style.top  = (38 + joyVec.y * JOY_RADIUS) + "px";
      requestAnimationFrame(desktopControlsToJoystick);
    }
    desktopControlsToJoystick();
  </script>
</body>
</html>
