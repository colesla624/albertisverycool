<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minecraft-like Game â€” Chunked Loading, Smooth Capsule, Drag Look</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }

    .btn {
      padding: 10px 14px;
      background: rgba(30,30,30,0.65);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.35);
      border-radius: 8px;
      font-size: 14px;
      backdrop-filter: blur(4px);
      user-select: none;
      touch-action: manipulation;
    }
    #povBtn { position: absolute; top: 12px; left: 12px; z-index: 10; }

    #uiRight {
      position: absolute;
      right: 14px;
      bottom: 140px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
    }
    #jumpBtn { position: absolute; right: 14px; bottom: 20px; z-index: 10; }

    #joystick {
      position: absolute;
      bottom: 24px;
      left: 24px;
      width: 150px;
      height: 150px;
      background: rgba(200,200,200,0.18);
      border: 2px solid rgba(255,255,255,0.25);
      border-radius: 50%;
      touch-action: none;
      z-index: 10;
    }
    #stick {
      position: absolute;
      width: 68px;
      height: 68px;
      background: rgba(100,100,100,0.65);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      left: 41px; top: 41px;
      touch-action: none;
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px; height: 20px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 5;
    }
    #crosshair::before, #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 0 2px rgba(0,0,0,0.4);
    }
    #crosshair::before { width: 2px; height: 20px; left: 9px; top: 0; }
    #crosshair::after { width: 20px; height: 2px; left: 0; top: 9px; }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <button id="povBtn" class="btn">POV: Third</button>

  <div id="uiRight">
    <button id="placeBtn" class="btn">Place</button>
    <button id="deleteBtn" class="btn">Delete</button>
  </div>
  <button id="jumpBtn" class="btn">Jump</button>

  <div id="joystick"><div id="stick"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    // ---------- Utilities: seeded 2D noise ----------
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }
    function makeNoise2D(seed = 12345) {
      const rand = mulberry32(seed);
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) perm[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 256; i++) perm[256 + i] = perm[i];
      function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
      function lerp(a, b, t) { return a + t * (b - a); }
      function grad(hash, x, y) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
      }
      return function(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x), v = fade(y);
        const aa = perm[X + perm[Y]];
        const ab = perm[X + perm[Y + 1]];
        const ba = perm[X + 1 + perm[Y]];
        const bb = perm[X + 1 + perm[Y + 1]];
        return lerp(lerp(grad(aa, x, y), grad(ba, x - 1, y), u),
                    lerp(grad(ab, x, y - 1), grad(bb, x - 1, y - 1), u), v);
      };
    }

    // ---------- Three.js setup ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1200);
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x889988, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(20, 30, 10);
    scene.add(hemi); scene.add(dir);

    // ---------- World and chunks ----------
    const WORLD_SIZE = 256;     // logical world extent
    const MAX_HEIGHT = 20;
    const CHUNK_SIZE = 16;      // chunk dimensions (x,z)
    const VIEW_RADIUS = 3;      // chunks radius to load around player

    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    const matGrass = new THREE.MeshLambertMaterial({ color: 0x3a9d23 });
    const matDirt  = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
    const matStone = new THREE.MeshLambertMaterial({ color: 0x7f7f7f });

    // World data: sparse dictionary of blocks
    const world = new Map(); // key "x,y,z" -> type
    function k(x,y,z){ return `${x},${y},${z}`; }
    function getBlock(x,y,z){ return world.get(k(x,y,z)); }
    function setBlock(x,y,z,type){ world.set(k(x,y,z), type); }
    function clearBlock(x,y,z){ world.delete(k(x,y,z)); }

    // Generate terrain in data only (no meshes yet)
    const noise = makeNoise2D(1337);
    const SCALE = 0.06;
    for (let x = 0; x < WORLD_SIZE; x++) {
      for (let z = 0; z < WORLD_SIZE; z++) {
        const nx = x * SCALE, nz = z * SCALE;
        const hVal = (noise(nx, nz) * 0.6) + (noise(nx * 0.5, nz * 0.5) * 0.4);
        const height = Math.floor((hVal * 0.5 + 0.5) * MAX_HEIGHT);
        for (let y = 0; y <= height; y++) {
          const type = y === height ? "grass" : (y > height - 3 ? "dirt" : "stone");
          setBlock(x,y,z,type);
        }
      }
    }

    // Chunks: load/unload visible groups
    const chunks = new Map(); // key "cx,cz" -> { group, meshCount }
    function chunkKey(cx,cz){ return `${cx},${cz}`; }

    function buildChunkMesh(cx, cz) {
      const group = new THREE.Group();
      let count = 0;
      const startX = cx * CHUNK_SIZE;
      const startZ = cz * CHUNK_SIZE;

      for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let lz = 0; lz < CHUNK_SIZE; lz++) {
          const wx = startX + lx;
          const wz = startZ + lz;
          for (let y = 0; y <= MAX_HEIGHT; y++) {
            const type = getBlock(wx,y,wz);
            if (!type) continue;
            const mat = type === "grass" ? matGrass : (type === "dirt" ? matDirt : matStone);
            const mesh = new THREE.Mesh(blockGeo, mat);
            mesh.position.set(wx + 0.5, y + 0.5, wz + 0.5);
            mesh.userData = { x: wx, y, z: wz };
            group.add(mesh);
            count++;
          }
        }
      }

      return { group, count };
    }

    function loadChunk(cx, cz) {
      const ck = chunkKey(cx, cz);
      if (chunks.has(ck)) return;
      const { group, count } = buildChunkMesh(cx, cz);
      if (count > 0) {
        scene.add(group);
        chunks.set(ck, { group, count });
      } else {
        chunks.set(ck, { group: null, count: 0 });
      }
    }

    function unloadFarChunks(centerCx, centerCz) {
      for (const [ck, data] of chunks) {
        const [sx, sz] = ck.split(',').map(Number);
        const dx = Math.abs(sx - centerCx);
        const dz = Math.abs(sz - centerCz);
        if (dx > VIEW_RADIUS || dz > VIEW_RADIUS) {
          if (data.group) scene.remove(data.group);
          chunks.delete(ck);
        }
      }
    }

    function updateVisibleChunks(px, pz) {
      const cx = Math.floor(px / CHUNK_SIZE);
      const cz = Math.floor(pz / CHUNK_SIZE);
      for (let dx = -VIEW_RADIUS; dx <= VIEW_RADIUS; dx++) {
        for (let dz = -VIEW_RADIUS; dz <= VIEW_RADIUS; dz++) {
          const ncx = cx + dx, ncz = cz + dz;
          if (ncx < 0 || ncz < 0 || ncx >= Math.ceil(WORLD_SIZE/CHUNK_SIZE) || ncz >= Math.ceil(WORLD_SIZE/CHUNK_SIZE)) continue;
          loadChunk(ncx, ncz);
        }
      }
      unloadFarChunks(cx, cz);
    }

    // Rebuild a single block in its chunk (after place/delete)
    function rebuildBlockMesh(x, y, z) {
      const cx = Math.floor(x / CHUNK_SIZE);
      const cz = Math.floor(z / CHUNK_SIZE);
      const ck = chunkKey(cx, cz);
      const cur = chunks.get(ck);
      if (!cur) return; // chunk not visible: no need now; it will be built when visible

      // Remove old group and rebuild
      if (cur.group) scene.remove(cur.group);
      const rebuilt = buildChunkMesh(cx, cz);
      if (rebuilt.count > 0) {
        scene.add(rebuilt.group);
        chunks.set(ck, rebuilt);
      } else {
        chunks.set(ck, { group: null, count: 0 });
      }
    }

    // ---------- Player capsule and movement ----------
    const capsuleRadius = 0.4;
    const capsuleMid = 1.0;
    const capsuleHeight = capsuleMid + 2 * capsuleRadius;
    const capsuleGeo = new THREE.CapsuleGeometry(capsuleRadius, capsuleMid, 8, 16);
    const capsuleMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
    const player = new THREE.Mesh(capsuleGeo, capsuleMat);
    player.position.set(WORLD_SIZE/2 + 0.5, MAX_HEIGHT + 8, WORLD_SIZE/2 + 0.5);
    scene.add(player);

    const playerVel = new THREE.Vector3(0, 0, 0);
    const GRAVITY = 22;
    const MOVE_SPEED = 5.2;
    const JUMP_SPEED = 9.2;
    let onGround = false;
    let pov = "third";

    let yaw = 0;
    let pitch = 0;

    function getFacingVectors() {
      const cosY = Math.cos(yaw), sinY = Math.sin(yaw);
      const forward = new THREE.Vector3(-sinY, 0, -cosY).normalize();
      const right   = new THREE.Vector3( cosY, 0, -sinY).normalize();
      return { forward, right };
    }

    // ---------- Joystick (inverted forward/backward) ----------
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");
    let joyVec = { x: 0, y: 0 };
    const JOY_RADIUS = 56;
    let joyCenter = null;

    function recalcJoyCenter() {
      const rect = joystick.getBoundingClientRect();
      joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    }
    recalcJoyCenter();
    window.addEventListener('resize', recalcJoyCenter);

    function updateJoystick(e) {
      const t = e.touches[0];
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const dist = Math.min(Math.hypot(dx, dy), JOY_RADIUS);
      const angle = Math.atan2(dy, dx);
      const rawX = Math.cos(angle) * (dist / JOY_RADIUS);
      const rawY = Math.sin(angle) * (dist / JOY_RADIUS);
      joyVec.x = rawX;
      joyVec.y = -rawY; // invert forward/backward
      stick.style.left = (41 + rawX * JOY_RADIUS) + "px";
      stick.style.top  = (41 + rawY * JOY_RADIUS) + "px";
    }
    joystick.addEventListener("touchstart", updateJoystick, { passive: true });
    joystick.addEventListener("touchmove", updateJoystick, { passive: true });
    joystick.addEventListener("touchend", () => {
      joyVec.x = 0; joyVec.y = 0;
      stick.style.left = "41px"; stick.style.top = "41px";
    });

    // ---------- Drag rotation (exclude joystick) ----------
    let dragging = false, lastX = 0, lastY = 0;
    document.addEventListener("touchstart", e => {
      if (e.target.closest("#joystick")) return;
      dragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener("touchmove", e => {
      if (!dragging) return;
      const tx = e.touches[0].clientX;
      const ty = e.touches[0].clientY;
      const dx = tx - lastX;
      const dy = ty - lastY;
      yaw -= dx * 0.005;
      pitch -= dy * 0.005;
      pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch));
      lastX = tx; lastY = ty;
    }, { passive: true });

    document.addEventListener("touchend", () => { dragging = false; }, { passive: true });

    // ---------- Buttons ----------
    const povBtn = document.getElementById("povBtn");
    const jumpBtn = document.getElementById("jumpBtn");
    const placeBtn = document.getElementById("placeBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    povBtn.addEventListener("click", () => {
      pov = (pov === "third") ? "first" : "third";
      povBtn.textContent = `POV: ${pov === "third" ? "Third" : "First"}`;
    });

    jumpBtn.addEventListener("click", () => {
      if (onGround) { playerVel.y = JUMP_SPEED; onGround = false; }
    });

    // ---------- Raycasting: against currently visible chunk meshes ----------
    const raycaster = new THREE.Raycaster();
    function getCenterRayHit() {
      const ndc = new THREE.Vector2(0, 0);
      raycaster.setFromCamera(ndc, camera);
      const visibleMeshes = [];
      for (const { group } of chunks.values()) {
        if (!group) continue;
        for (const child of group.children) visibleMeshes.push(child);
      }
      const hits = raycaster.intersectObjects(visibleMeshes, false);
      return hits.length ? hits[0] : null;
    }

    function placeBlockAtAim() {
      const hit = getCenterRayHit();
      if (!hit) return;
      const normalWorld = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
      const p = hit.point.clone().addScaledVector(normalWorld, 0.5);
      const x = Math.floor(p.x), y = Math.floor(p.y), z = Math.floor(p.z);
      if (x < 0 || z < 0 || x >= WORLD_SIZE || z >= WORLD_SIZE || y < 0 || y > MAX_HEIGHT + 20) return;
      setBlock(x,y,z,"grass");
      rebuildBlockMesh(x,y,z);
    }
    function deleteBlockAtAim() {
      const hit = getCenterRayHit();
      if (!hit) return;
      const { x, y, z } = hit.object.userData;
      clearBlock(x,y,z);
      rebuildBlockMesh(x,y,z);
    }
    placeBtn.addEventListener("click", placeBlockAtAim);
    deleteBtn.addEventListener("click", deleteBlockAtAim);

    // ---------- Collisions (capsule vs voxel data, stable snap) ----------
    function groundSnapAndDetect(dt) {
      let nextY = player.position.y + playerVel.y * dt;
      const footY = nextY - capsuleHeight / 2;

      const px = player.position.x;
      const pz = player.position.z;

      const minX = Math.floor(px - capsuleRadius + 0.001);
      const maxX = Math.floor(px + capsuleRadius - 0.001);
      const minZ = Math.floor(pz - capsuleRadius + 0.001);
      const maxZ = Math.floor(pz + capsuleRadius - 0.001);

      const probeY = Math.floor(footY - 0.05);
      let highestGround = -Infinity;
      for (let x = minX; x <= maxX; x++) {
        for (let z = minZ; z <= maxZ; z++) {
          if (getBlock(x, probeY, z)) {
            highestGround = Math.max(highestGround, probeY + 1);
          }
        }
      }

      if (highestGround !== -Infinity && playerVel.y <= 0) {
        const desiredPlayerY = highestGround + capsuleHeight / 2;
        if (nextY < desiredPlayerY) {
          player.position.y = desiredPlayerY;
          playerVel.y = 0;
          onGround = true;
          return;
        }
      }

      player.position.y = nextY;
      onGround = false;
    }

    function horizontalResolve(axis) {
      const radius = capsuleRadius;
      const halfH = capsuleHeight / 2;
      const centerY = player.position.y;

      const px = player.position.x;
      const pz = player.position.z;

      const minX = Math.floor(px - radius - 1);
      const maxX = Math.floor(px + radius + 1);
      const minY = Math.floor(centerY - halfH);
      const maxY = Math.floor(centerY + halfH);
      const minZ = Math.floor(pz - radius - 1);
      const maxZ = Math.floor(pz + radius + 1);

      for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
          for (let z = minZ; z <= maxZ; z++) {
            if (!getBlock(x,y,z)) continue;
            const bx = x + 0.5, by = y + 0.5, bz = z + 0.5;
            const dx = px - bx;
            const dz = pz - bz;
            const vertGap = Math.max(0, Math.abs(centerY - by) - 0.5);
            const horizDist = Math.hypot(dx, dz);

            if (vertGap < halfH && horizDist < radius + 0.5) {
              const overlap = (radius + 0.5) - horizDist;
              if (overlap > 0) {
                const nx = dx / (horizDist || 1e-6);
                const nz = dz / (horizDist || 1e-6);
                if (axis === 'x') player.position.x += nx * overlap;
                else              player.position.z += nz * overlap;
              }
            }
          }
        }
      }
    }

    // ---------- Camera with smoothing ----------
    const camPos = new THREE.Vector3();
    const camTarget = new THREE.Vector3();
    const CAM_LERP = 0.18;

    function updateCamera() {
      const { forward } = getFacingVectors();
      const target = player.position.clone();

      if (pov === "first") {
        const eye = target.clone().add(new THREE.Vector3(0, capsuleHeight * 0.35, 0));
        const lookDir = new THREE.Vector3(forward.x, Math.sin(pitch), forward.z).normalize();
        camPos.copy(eye);
        camTarget.copy(eye).add(lookDir);
      } else {
        const distance = 7.5;
        const offX = Math.sin(yaw) * Math.cos(pitch) * distance;
        const offZ = Math.cos(yaw) * Math.cos(pitch) * distance;
        const offY = Math.sin(pitch) * distance * 0.6;
        const desiredPos = target.clone().add(new THREE.Vector3(-offX, 1.6 + offY, -offZ));
        camPos.lerp(desiredPos, CAM_LERP);
        camTarget.lerp(target.clone().add(new THREE.Vector3(0, 1.2, 0)), CAM_LERP);
      }

      camera.position.copy(camPos);
      camera.lookAt(camTarget);
    }

    // ---------- Main loop ----------
    let lastTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.033);
      lastTime = now;

      // Load/unload visible chunks around player
      updateVisibleChunks(player.position.x, player.position.z);

      // Gravity
      playerVel.y -= GRAVITY * dt;

      // Movement
      const { forward, right } = getFacingVectors();
      const moveDir = new THREE.Vector3()
        .addScaledVector(right, joyVec.x)
        .addScaledVector(forward, joyVec.y);
      if (moveDir.lengthSq() > 0) moveDir.normalize();

      const vx = moveDir.x * MOVE_SPEED;
      const vz = moveDir.z * MOVE_SPEED;

      // Vertical: stable snap (no bounce)
      groundSnapAndDetect(dt);

      // Horizontal: X then Z resolution
      player.position.x += vx * dt;
      horizontalResolve('x');

      player.position.z += vz * dt;
      horizontalResolve('z');

      // Bounds
      player.position.x = Math.max(capsuleRadius, Math.min(WORLD_SIZE - capsuleRadius, player.position.x));
      player.position.z = Math.max(capsuleRadius, Math.min(WORLD_SIZE - capsuleRadius, player.position.z));
      if (player.position.y < capsuleHeight / 2) {
        player.position.y = capsuleHeight / 2;
        playerVel.y = 0;
        onGround = true;
      }

      updateCamera();
      renderer.render(scene, camera);
    }
    animate();

    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      recalcJoyCenter();
    });

    // ---------- Desktop fallbacks (WASD + Space) ----------
    const keys = new Set();
    window.addEventListener('keydown', e => {
      keys.add(e.code);
      if (e.code === "Space") jumpBtn.click();
    });
    window.addEventListener('keyup', e => keys.delete(e.code));
    function desktopControlsToJoystick() {
      let x = 0, y = 0;
      if (keys.has("KeyA")) x -= 1;
      if (keys.has("KeyD")) x += 1;
      if (keys.has("KeyW")) y += 1;  // backward (inverted)
      if (keys.has("KeyS")) y -= 1;  // forward
      const len = Math.hypot(x, y);
      if (len > 0) { x /= len; y /= len; }
      joyVec.x = x; joyVec.y = y;
      stick.style.left = (41 + x * JOY_RADIUS) + "px";
      stick.style.top  = (41 + (-y) * JOY_RADIUS) + "px";
      requestAnimationFrame(desktopControlsToJoystick);
    }
    desktopControlsToJoystick();
  </script>
</body>
</html>
