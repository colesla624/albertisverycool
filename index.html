<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Third Person Multiâ€‘Level Platformer</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#0b1026; }
  #hud { position:fixed; top:10px; left:50%; transform:translateX(-50%); font-size:14px; color:#e9ecff; }
  .stick {
    position:fixed; bottom:16px; width:120px; height:120px; border-radius:50%;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.18);
    touch-action:none;
  }
  #stickLeft { left:16px; }
  #stickRight { right:16px; }
  .knob {
    position:absolute; left:50%; top:50%; width:54px; height:54px; border-radius:50%;
    transform:translate(-50%,-50%); background:rgba(97,225,255,0.35);
  }
  #btnJump {
    position:fixed; right:18px; bottom:150px; width:76px; height:76px; border-radius:50%;
    background:#202859; color:#e9ecff; font-size:16px;
  }
</style>
</head>
<body>
<div id="hud">Level: <span id="level">1</span> | Crystals: <span id="score">0</span></div>
<div id="stickLeft" class="stick"><div class="knob"></div></div>
<div id="stickRight" class="stick"><div class="knob"></div></div>
<button id="btnJump">Jump</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1026);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 500);

  scene.add(new THREE.HemisphereLight(0x8a5cff,0x0b1026,0.9));
  const dir = new THREE.DirectionalLight(0xffffff,1.0);
  dir.position.set(40,50,25);
  scene.add(dir);

  const matGround = new THREE.MeshStandardMaterial({ color:0x1b2250 });
  const matPlat = new THREE.MeshStandardMaterial({ color:0x61e1ff, emissive:0x103a46, emissiveIntensity:0.25 });
  const matCrystal = new THREE.MeshStandardMaterial({ color:0xffd46b, emissive:0x704f10, emissiveIntensity:0.6 });
  const matPlayer = new THREE.MeshStandardMaterial({ color:0xff7aa2 });

  const ground = new THREE.Mesh(new THREE.BoxGeometry(80,2,80), matGround);
  ground.position.y=-1;
  scene.add(ground);

  const player={pos:new THREE.Vector3(0,2,5), vel:new THREE.Vector3(), yaw:0, grounded:false, speed:6, jumpVel:15};
  const playerMesh=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,1,8,16),matPlayer);
  scene.add(playerMesh);

  const camOffset=new THREE.Vector3(0,2.5,6.5);
  function updateCamera(){
    const cos=Math.cos(player.yaw),sin=Math.sin(player.yaw);
    const offset=new THREE.Vector3(camOffset.x*cos+camOffset.z*sin,camOffset.y,-camOffset.x*sin+camOffset.z*cos);
    camera.position.copy(player.pos).add(offset);
    camera.lookAt(player.pos);
  }

  let moveStick={x:0,y:0}, lookStick={x:0,y:0};
  function setupStick(el,onMove){
    const knob=el.querySelector(".knob"); let active=false;
    el.addEventListener("touchstart",()=>{active=true;},{passive:true});
    el.addEventListener("touchmove",e=>{
      if(!active)return; const rect=el.getBoundingClientRect(); const t=e.touches[0];
      const dx=t.clientX-(rect.left+rect.width/2); const dy=t.clientY-(rect.top+rect.height/2);
      const r=50,mag=Math.hypot(dx,dy),cl=mag>r?r/mag:1; const nx=dx*cl,ny=dy*cl;
      knob.style.transform=`translate(${nx}px,${ny}px) translate(-50%,-50%)`; onMove(nx/r,ny/r); e.preventDefault();
    },{passive:false});
    function reset(){active=false;knob.style.transform="translate(-50%,-50%";onMove(0,0);}
    el.addEventListener("touchend",reset,{passive:true});
    el.addEventListener("touchcancel",reset,{passive:true});
  }
  setupStick(document.getElementById("stickLeft"),(x,y)=>{moveStick.x=x;moveStick.y=y;});
  setupStick(document.getElementById("stickRight"),(x,y)=>{lookStick.x=x;lookStick.y=y;});

  document.getElementById("btnJump").addEventListener("click",()=>{if(player.grounded){player.vel.y=player.jumpVel;player.grounded=false;}});

  function getAABB(mesh){
    mesh.geometry.computeBoundingBox();
    const bb=mesh.geometry.boundingBox.clone();
    bb.min.add(mesh.position);
    bb.max.add(mesh.position);
    return bb;
  }
  function checkCollisions(){
    player.grounded=false;
    const colliders=platforms.concat([ground]);
    for(const m of colliders){
      const bb=getAABB(m);
      if(player.pos.x>=bb.min.x-0.5 && player.pos.x<=bb.max.x+0.5 &&
         player.pos.z>=bb.min.z-0.5 && player.pos.z<=bb.max.z+0.5){
        if(player.pos.y<=bb.max.y+0.1 && player.pos.y>=bb.max.y-1){
          player.pos.y=bb.max.y;
          player.vel.y=0;
          player.grounded=true;
        }
      }
    }
  }

  let platforms=[], crystals=[], level=1, score=0;
  const scoreEl=document.getElementById("score"), levelEl=document.getElementById("level");

  function addPlatform(x,y,z){const m=new THREE.Mesh(new THREE.BoxGeometry(8,1,8),matPlat);m.position.set(x,y,z);scene.add(m);platforms.push(m);}
  function addCrystal(x,y,z){const c=new THREE.Mesh(new THREE.ConeGeometry(0.6,1.6,10),matCrystal);c.position.set(x,y+1.2,z);scene.add(c);crystals.push(c);}

  function buildLevel(n){
    platforms.forEach(p=>scene.remove(p)); crystals.forEach(c=>scene.remove(c));
    platforms=[]; crystals=[];
    if(n===1){
      addPlatform(0,2,-10); addPlatform(12,4,-15); addPlatform(-8,3,-20);
      addCrystal(12,5,-15); addCrystal(-8,4,-20);
    }
    if(n===2){
      addPlatform(-10,2,-10); addPlatform(-20,4,-20); addPlatform(-30,6,-30);
      addCrystal(-20,5,-20); addCrystal(-30,7,-30);
    }
    if(n===3){
      addPlatform(10,2,10); addPlatform(20,4,20); addPlatform(30,6,30);
      addCrystal(20,5,20); addCrystal(30,7,30);
    }
    levelEl.textContent=n;
    score=0; scoreEl.textContent=score;
    player.pos.set(0,2,5); player.vel.set(0,0,0);
  }

  buildLevel(level);

  function loop(){
    requestAnimationFrame(loop);
    const dt=0.016;
    let fwd=moveStick.y; let str=moveStick.x;
    const len=Math.hypot(fwd,str); if(len>1){fwd/=len;str/=len;}
    const cos=Math.cos(player.yaw),sin=Math.sin(player.yaw);
    player.pos.x+=(str*cos+fwd*sin)*player.speed*dt;
    player.pos.z+=(str*-sin+fwd*cos)*player.speed*dt;
    player.vel.y-=9.8*dt; player
