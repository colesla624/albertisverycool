<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Third Person Platformer â€” Mobile Controls</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#0b1026; font-family:sans-serif; color:#e9ecff; }
  #hud { position:fixed; top:10px; left:50%; transform:translateX(-50%); font-size:14px; }
  .stick {
    position:fixed; bottom:16px; width:120px; height:120px; border-radius:50%;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.18);
    touch-action:none;
  }
  #stickLeft { left:16px; }
  #stickRight { right:16px; }
  .knob {
    position:absolute; left:50%; top:50%; width:54px; height:54px; border-radius:50%;
    transform:translate(-50%,-50%); background:rgba(97,225,255,0.35);
  }
  #btnJump {
    position:fixed; right:18px; bottom:150px; width:76px; height:76px; border-radius:50%;
    background:#202859; color:#e9ecff; font-size:16px;
  }
</style>
</head>
<body>
<div id="hud">Crystals: <span id="score">0</span></div>
<div id="stickLeft" class="stick"><div class="knob"></div></div>
<div id="stickRight" class="stick"><div class="knob"></div></div>
<button id="btnJump">Jump</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
(() => {
  // Scene setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1026);
  scene.fog = new THREE.Fog(0x0b1026, 60, 200);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 500);

  // Lighting
  scene.add(new THREE.HemisphereLight(0x8a5cff,0x0b1026,0.9));
  const dir = new THREE.DirectionalLight(0xffffff,1.0);
  dir.position.set(40,50,25);
  scene.add(dir);

  // Materials
  const matGround = new THREE.MeshStandardMaterial({ color:0x1b2250 });
  const matPlat = new THREE.MeshStandardMaterial({ color:0x61e1ff, emissive:0x103a46, emissiveIntensity:0.25 });
  const matCrystal = new THREE.MeshStandardMaterial({ color:0xffd46b, emissive:0x704f10, emissiveIntensity:0.6 });
  const matPlayer = new THREE.MeshStandardMaterial({ color:0xff7aa2 });

  // Ground
  const ground = new THREE.Mesh(new THREE.BoxGeometry(80,2,80), matGround);
  ground.position.y=-1;
  scene.add(ground);

  // Platforms
  const platforms=[];
  function addPlatform(x,y,z){ const m=new THREE.Mesh(new THREE.BoxGeometry(8,1,8),matPlat); m.position.set(x,y,z); scene.add(m); platforms.push(m); }
  addPlatform(0,2,-10); addPlatform(14,4,-12); addPlatform(26,6,-8);

  // Crystals
  const crystals=[];
  function addCrystal(x,y,z){ const c=new THREE.Mesh(new THREE.ConeGeometry(0.6,1.6,10),matCrystal); c.position.set(x,y+1.2,z); scene.add(c); crystals.push(c); }
  addCrystal(14,5,-12); addCrystal(26,7,-8);

  // Player
  const player={pos:new THREE.Vector3(0,1.1,0),vel:new THREE.Vector3(),yaw:0,radius:0.5,height:1.8,grounded:false,speed:6,jumpVel:7.5};
  const playerMesh=new THREE.Mesh(new THREE.CapsuleGeometry(player.radius,player.height-2*player.radius,8,16),matPlayer);
  scene.add(playerMesh);

  // Camera follow
  const camOffset=new THREE.Vector3(0,2.5,6.5);
  function updateCamera(){
    const cos=Math.cos(player.yaw),sin=Math.sin(player.yaw);
    const offset=new THREE.Vector3(camOffset.x*cos+camOffset.z*sin,camOffset.y,-camOffset.x*sin+camOffset.z*cos);
    camera.position.copy(player.pos).add(offset);
    camera.lookAt(player.pos);
  }

  // Joysticks
  let moveStick={x:0,y:0}, lookStick={x:0,y:0};
  function setupStick(el,onMove){
    const knob=el.querySelector(".knob"); let active=false;
    el.addEventListener("touchstart",()=>{active=true;},{passive:true});
    el.addEventListener("touchmove",e=>{
      if(!active)return; const rect=el.getBoundingClientRect(); const t=e.touches[0];
      const dx=t.clientX-(rect.left+rect.width/2); const dy=t.clientY-(rect.top+rect.height/2);
      const r=50,mag=Math.hypot(dx,dy),cl=mag>r?r/mag:1; const nx=dx*cl,ny=dy*cl;
      knob.style.transform=`translate(${nx}px,${ny}px) translate(-50%,-50%)`; onMove(nx/r,ny/r); e.preventDefault();
    },{passive:false});
    function reset(){active=false;knob.style.transform="translate(-50%,-50%)";onMove(0,0);}
    el.addEventListener("touchend",reset,{passive:true});
    el.addEventListener("touchcancel",reset,{passive:true});
  }
  setupStick(document.getElementById("stickLeft"),(x,y)=>{moveStick.x=x;moveStick.y=y;});
  setupStick(document.getElementById("stickRight"),(x,y)=>{lookStick.x=x;lookStick.y=y;});

  // Jump button
  document.getElementById("btnJump").addEventListener("click",()=>{if(player.grounded){player.vel.y=player.jumpVel;player.grounded=false;}});

  // Collision helper
  function getAABB(mesh){mesh.geometry.computeBoundingBox();const bb=mesh.geometry.boundingBox.clone();bb.min.add(mesh.position);bb.max.add(mesh.position);return bb;}
  function resolveCollisions(pos,vel,radius,height,aabb){
    if(pos.x>=aabb.min.x-radius&&pos.x<=aabb.max.x+radius&&pos.y>=aabb.min.y-radius&&pos.y<=aabb.max.y+radius&&pos.z>=aabb.min.z-radius&&pos.z<=aabb.max.z+radius){
      if(pos.y>=(aabb.max.y)){pos.y=aabb.max.y;vel.y=Math.max(0,vel.y);player.grounded=true;}
    }
  }

  // Score
  let score=0; const scoreEl=document.getElementById("score");

  // Loop
  function loop(){
    requestAnimationFrame(loop);
    const dt=0.016;
    // Movement
    let fwd=moveStick.y; let str=moveStick.x;
    const len=Math.hypot(fwd,str); if(len>1){fwd/=len;str/=len;}
    const cos=Math.cos(player.yaw),sin=Math.sin(player.yaw);
    player.pos.x+=(str*cos+fwd*sin)*player.speed*dt;
    player.pos.z+=(str*-sin+fwd*cos)*player.speed*dt;
    // Gravity
    player.vel.y-=9.8*dt; player.pos.y+=player.vel.y*dt; player.grounded=false;
    // Collisions
    const colliders=platforms.concat([ground]);
    for(const m of colliders){resolveCollisions(player.pos,player.vel,player.radius,player.height,getAABB(m));}
    if(player.pos.y<-20){player.pos.set(0,1.1,0);player.vel.set(0,0,0);}
    // Update mesh
    playerMesh.position.copy(player.pos);
    // Camera rotation from right stick
    player.yaw-=lookStick.x*2.5*dt;
    updateCamera();
    // Collect crystals
    for(let i=crystals.length-1;i>=0;i--){if(player.pos.distanceTo(crystals
