<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Builder Game - Minecraft Hotbar (V31 - Count Locked to Corner)</title>
    <!-- Load Tailwind CSS for easy UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom CSS for the canvas and overall layout */
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Prevents default browser touch actions */
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }

        /* Action button refinement */
        .action-btn {
            @apply shadow-2xl transition transform active:scale-95 text-white font-bold rounded-full;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
            -webkit-tap-highlight-color: transparent;
        }

        /* Fixed Joystick Base Styles */
        #joystick-base {
            position: absolute;
            bottom: 30px; 
            left: 30px; 
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            z-index: 50;
            opacity: 0.8; 
        }

        /* Joystick Handle Styles (will move) */
        #joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            z-index: 60;
            opacity: 0; 
        }
        
        /* Minecraft Hotbar Styles */
        #hotbar {
            /* Mimics the dark, segmented Minecraft texture */
            background-color: #1c1c1c; 
            border: 3px solid #000000;
            padding: 2px; 
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .hotbar-slot {
            /* Enforce fixed square size for all devices */
            width: 4rem; /* 64px */
            height: 4rem; /* 64px */
            
            /* Crucial: Set to relative so .slot-count can use absolute positioning relative to this slot */
            @apply flex items-center justify-center 
                   relative cursor-pointer 
                   bg-gray-500 bg-opacity-30; 
            
            margin: 1px; 
            border: 2px solid #000000; 
            transition: all 0.1s; 
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        /* Minecraft Active Slot Frame - Thicker and Bolder */
        .hotbar-slot.active {
            border: none; 
            outline: 5px solid #ffffff; 
            outline-offset: -3px; 
            box-shadow: 0 0 18px rgba(255, 255, 255, 0.7); 
        }
        
        .slot-item-display {
            /* Item inside the slot - takes up 100% of the slot area. This is the colored block. */
            @apply p-1 w-full h-full text-center font-bold flex flex-col justify-center items-center;
            color: white; 
            font-size: 1.8rem; 
            text-shadow: 1px 1px 3px #000; 
            line-height: 1;
        }
        
        .slot-count {
             /* ABSOLUTE POSITIONING to lock it to the corner of the .hotbar-slot */
             position: absolute;
             bottom: 4px; /* Precise offset from the bottom edge */
             right: 4px; /* Precise offset from the right edge */
             
             /* Visual Styles */
             font-size: 0.9rem; 
             font-weight: 900; 
             color: white !important; 
             line-height: 1; 
             text-align: right;
             z-index: 10; /* Ensure count is on top of the colored block */
             
             /* Outline for maximum visibility against any block color */
             text-shadow: 
                -1px -1px 0 #000,  
                 1px -1px 0 #000,
                -1px 1px 0 #000,
                 1px 1px 0 #000; 
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 3D Canvas will be injected here -->
        <div id="crosshair"></div>

        <!-- Health and View HUD (Top Center/Right) -->
        <div class="absolute top-4 left-1/2 transform -translate-x-1/2 flex space-x-6 z-20">
            <!-- Health Hearts Display -->
            <div id="health-bar" class="p-2 bg-red-900 bg-opacity-70 rounded-xl shadow-lg flex space-x-1">
                <!-- Hearts will be dynamically injected here -->
            </div>
        </div>

        <!-- View Toggle Button (Top Right) -->
        <button id="view-toggle-btn" class="absolute top-4 right-4 action-btn bg-purple-500 hover:bg-purple-600 active:bg-purple-700 p-3 text-sm z-30 w-32 h-12">
            Toggle View (FP)
        </button>

        <!-- Fixed Joystick Base (Mobile) -->
        <div id="joystick-base"></div>
        <!-- Dynamic Joystick Handle (Mobile) -->
        <div id="joystick-handle"></div>

        <!-- Mobile Action Buttons (Right Side) -->
        <div id="action-buttons" class="absolute bottom-6 right-6 flex flex-col space-y-4 z-20">
            <!-- Jump Button -->
            <button id="jump-btn" class="action-btn w-16 h-16 bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-3xl">
                ↑
            </button>
            <!-- Place Block -->
            <button id="place-btn" class="action-btn w-16 h-16 bg-green-500 hover:bg-green-600 active:bg-green-700 text-4xl">
                +
            </button>
            <!-- Mine Block -->
            <button id="mine-btn" class="action-btn w-16 h-16 bg-red-500 hover:bg-red-600 active:bg-red-700 text-4xl">
                -
            </button>
        </div>
        
        <!-- Hotbar (Bottom Center) -->
        <div id="hotbar" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 rounded-lg z-30 flex">
            <!-- Slots will be dynamically injected here -->
        </div>

        <!-- Message Box for Damage/Death -->
        <div id="message-box" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
            <div class="bg-red-700 p-8 rounded-xl shadow-2xl text-white text-center">
                <h2 id="message-title" class="text-3xl font-bold mb-4"></h2>
                <p id="message-content" class="text-xl mb-6"></p>
                <button id="respawn-btn" class="action-btn bg-blue-500 hover:bg-blue-600 px-6 py-3 text-lg">Respawn</button>
            </div>
        </div>
        
        <!-- Loading is now just for show since no assets are loaded -->
        <div id="loading" class="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-90 z-50">
            <p class="absolute text-white">Initializing World...</p>
        </div>

    </div>

    <script type="module">
        // --- Core Global Variables ---
        let scene, camera, renderer;
        let playerModel; 
        let opaqueMesh; 
        let transparentGroup; 
        let cameraY; 
        
        // --- Game State: Health and Inventory ---
        const MAX_HEALTH = 10; // 5 hearts
        let isDead = false;
        
        let inventory = [
            { type: null, count: 0 },
            { type: null, count: 0 },
            { type: null, count: 0 },
            { type: null, count: 0 },
            { type: null, count: 0 },
            { type: null, count: 0 },
            { type: null, count: 0 },
            { type: null, count: 0 },
            { type: null, count: 0 }
        ];
        let activeSlotIndex = 0;
        let activeItem = inventory[0];

        // --- Materials ---
        const OPAQUE_MATERIAL = new THREE.MeshStandardMaterial({
            vertexColors: true, 
            metalness: 0.1,
            roughness: 0.8,
        });
        const GLASS_MATERIAL = new THREE.MeshStandardMaterial({
            color: 0x99FFFF, 
            transparent: true,
            opacity: 0.4,
            metalness: 0.1,
            roughness: 0.1,
        });
        
        // Block Definitions (using hex colors)
        const DIRT_COLOR = 0x6E3D27; 
        
        const blockTypes = {
            GRASS: { 
                name: 'Grass', 
                key: 'GRASS', 
                opaque: true, 
                colors: { TOP: 0x07A921, SIDE: DIRT_COLOR, BOTTOM: DIRT_COLOR },
                iconColor: 0x07A921 
            },
            DIRT: { 
                name: 'Dirt', 
                key: 'DIRT', 
                opaque: true, 
                color: DIRT_COLOR, 
                iconColor: DIRT_COLOR 
            },
            STONE: { 
                name: 'Stone', 
                key: 'STONE', 
                opaque: true, 
                color: 0x9E9E9E, 
                iconColor: 0x9E9E9E 
            },
            WOOD: { 
                name: 'Wood', 
                key: 'WOOD', 
                opaque: true, 
                color: 0x5D4037, 
                iconColor: 0x5D4037 
            },
            GLASS: { 
                name: 'Glass', 
                key: 'GLASS', 
                opaque: false, 
                color: 0x99FFFF, 
                iconColor: 0x99FFFF 
            }
        };
        
        const worldBlockData = new Map(); 
        
        // --- Physics & Player Constants ---
        const GRAVITY = 0.0185;         
        const TERMINAL_VELOCITY = 0.5;  
        const JUMP_VELOCITY = 0.25;     
        const EPSILON = 0.0001; 
        
        // --- Movement Constants ---
        const MAX_WALK_SPEED = 0.115;    
        const ACCELERATION = 0.008;      
        const FRICTION = 0.4;            
        const FALL_DAMAGE_VELOCITY_THRESHOLD = 0.35; 
        const FALL_DAMAGE_MULTIPLIER = 10; 
        
        // Player's velocity vector
        let velocity = new THREE.Vector3(0, 0, 0); 
        
        // Player Collision Box (AABB)
        const playerPhysicsHeight = 1.8; 
        const playerVisualHeight = 1.4;  
        const playerRadius = 0.3; 
        const playerYOffset = -1.7; 
        
        // Player state and constants
        const player = {
            position: new THREE.Vector3(0, 10, 0), 
            rotationY: 0, 
            onGround: false,
            health: MAX_HEALTH, 
            lastFallVelocity: 0, 
        };
        const lookSpeed = 0.002; 

        // World Generation Constants
        const WORLD_SIZE = 64; 
        const MAX_HEIGHT = 16;
        
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        
        const CUBE_FACES = [
            { dir: [1, 0, 0], face: 0, normal: [1, 0, 0], side: 'SIDE' },
            { dir: [-1, 0, 0], face: 1, normal: [-1, 0, 0], side: 'SIDE' },
            { dir: [0, 1, 0], face: 2, normal: [0, 1, 0], side: 'TOP' },
            { dir: [0, -1, 0], face: 3, normal: [0, -1, 0], side: 'BOTTOM' },
            { dir: [0, 0, 1], face: 4, normal: [0, 0, 1], side: 'SIDE' },
            { dir: [0, 0, -1], face: 5, normal: [0, 0, -1], side: 'SIDE' }
        ];
        
        // --- Control Variables ---
        let controls = { forward: 0, backward: 0, left: 0, right: 0, up: false, down: false };
        let isThirdPerson = false;
        const thirdPersonDistance = 3.5; 
        const thirdPersonHeightOffset = 1.0; 
        const cameraLook = { yaw: 0, pitch: 0 };
        const joystick = { active: false, touchId: null, base: document.getElementById('joystick-base'), handle: document.getElementById('joystick-handle'), baseX: 0, baseY: 0, radius: 60, maxDistance: 40 };
        let activeLookTouch = null; 

        // --- Three.js Setup and Helpers ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 10);

        function getKey(x, y, z) {
            return `${x},${y},${z}`;
        }
        
        function getBlockTypeAt(x, y, z) {
             return worldBlockData.get(getKey(Math.floor(x), Math.floor(y), Math.floor(z)));
        }

        function isBlockAt(x, y, z) {
            return worldBlockData.has(getKey(Math.floor(x), Math.floor(y), Math.floor(z)));
        }

        /**
         * Creates a flat-bottomed capsule (rounded cylinder) geometry for the player model.
         */
        function createCapsuleGeometry(radius, height, radialSegments) {
            const material = new THREE.MeshStandardMaterial({ color: 0x33AFFF });
            
            const cylinderHeightFlat = height - radius; 

            const cylinder = new THREE.CylinderGeometry(radius, radius, cylinderHeightFlat, radialSegments, 1);
            const cylinderMesh = new THREE.Mesh(cylinder, material);
            cylinderMesh.position.y = cylinderHeightFlat / 2; 

            const topSphere = new THREE.SphereGeometry(radius, radialSegments, radialSegments / 2);
            const topMesh = new THREE.Mesh(topSphere, material);
            topMesh.position.y = cylinderHeightFlat; 
            
            const group = new THREE.Group();
            group.add(cylinderMesh, topMesh);
            
            return group; 
        }

        /**
         * Creates and initializes the player visualization model.
         */
        function createPlayerModel() {
            playerModel = new THREE.Group();
            const capsuleVisual = createCapsuleGeometry(playerRadius, playerVisualHeight, 16);
            
            playerModel.add(capsuleVisual);
            
            playerModel.position.copy(player.position);
            playerModel.visible = isThirdPerson; 
            scene.add(playerModel);
        }

        // --- World Generation and Optimization (Unchanged) ---
        
        function getHeight(x, z) {
            const baseHeight = 4;
            const lowFreqNoise = Math.sin(x * 0.05) * 5 + Math.cos(z * 0.05) * 5;
            const highFreqNoise = Math.sin(x * 0.2) * 2 + Math.cos(z * 0.2) * 2;
            
            let height = Math.floor(baseHeight + lowFreqNoise + highFreqNoise); 
            height = Math.max(1, Math.min(MAX_HEIGHT, height)); 
            return height;
        }

        function populateWorldData() {
            worldBlockData.clear();
            const offset = Math.floor(WORLD_SIZE / 2);

            for (let x = -offset; x <= offset; x++) {
                for (let z = -offset; z <= offset; z++) {
                    
                    const groundHeight = getHeight(x, z); 
                    
                    for (let y = 0; y < groundHeight; y++) {
                        let type;
                        if (y === groundHeight - 1) {
                            type = blockTypes.GRASS; 
                        } else if (y >= groundHeight - 4) {
                            type = blockTypes.DIRT; 
                        } else {
                            type = blockTypes.STONE; 
                        }
                        worldBlockData.set(getKey(x, y, z), type);
                    }
                }
            }
        }
        
        /**
         * Generates the opaque mesh (merged) and the transparent blocks (individual meshes).
         */
        function generateMeshes() {
            const positions = [];
            const normals = [];
            const colors = []; 
            const transparentBlocks = new THREE.Group();

            const tempBoxGeometry = blockGeometry.clone();
            const indexAttribute = tempBoxGeometry.index;

            worldBlockData.forEach((type, key) => {
                const [x, y, z] = key.split(',').map(Number);
                
                if (type.opaque) {
                    
                    // Add to Opaque Mesh (with Culling)
                    CUBE_FACES.forEach(face => {
                        const nx = x + face.dir[0];
                        const ny = y + face.dir[1];
                        const nz = z + face.dir[2];

                        const neighborType = getBlockTypeAt(nx, ny, nz);

                        if (!neighborType || !neighborType.opaque) {
                            
                            let faceColorHex;
                            if (type.key === 'GRASS') {
                                faceColorHex = type.colors[face.side];
                            } else {
                                faceColorHex = type.color;
                            }
                            const tempColor = new THREE.Color(faceColorHex);

                            tempBoxGeometry.translate(x + 0.5, y + 0.5, z + 0.5);
                            
                            const positionAttribute = tempBoxGeometry.attributes.position;
                            const startIndex = face.face * 6; 
                            
                            for (let i = 0; i < 6; i++) {
                                const vertexIndex = indexAttribute.getX(startIndex + i);
                                
                                positions.push(positionAttribute.getX(vertexIndex), positionAttribute.getY(vertexIndex), positionAttribute.getZ(vertexIndex));
                                normals.push(face.normal[0], face.normal[1], face.normal[2]);
                                colors.push(tempColor.r, tempColor.g, tempColor.b); 
                            }

                            tempBoxGeometry.translate(-(x + 0.5), -(y + 0.5), -(z + 0.5));
                        }
                    });
                } else {
                    // Transparent Blocks (Individual Mesh)
                    const mesh = new THREE.Mesh(blockGeometry, GLASS_MATERIAL);
                    mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    mesh.userData.isWorld = true;
                    transparentBlocks.add(mesh);
                }
            });
            
            const opaqueGeometry = new THREE.BufferGeometry();
            opaqueGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            opaqueGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); 
            opaqueGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3)); 

            const mesh = new THREE.Mesh(opaqueGeometry, OPAQUE_MATERIAL);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.isWorld = true; 
            
            return { opaque: mesh, transparent: transparentBlocks };
        }

        function refreshWorldMesh() {
            if (opaqueMesh) {
                scene.remove(opaqueMesh);
                opaqueMesh.geometry.dispose();
            }
            if (transparentGroup) {
                scene.remove(transparentGroup);
            }

            const meshes = generateMeshes();

            opaqueMesh = meshes.opaque;
            transparentGroup = meshes.transparent;
            
            scene.add(opaqueMesh);
            scene.add(transparentGroup);
        }
        
        // --- Collision, Movement, and Fall Damage Logic (Unchanged) ---
        
        function isColliding(newPos) {
            const minX = Math.floor(newPos.x - playerRadius);
            const maxX = Math.floor(newPos.x + playerRadius);
            
            const minY = Math.floor(newPos.y + playerYOffset);
            const maxY = Math.floor(newPos.y); 

            const minZ = Math.floor(newPos.z - playerRadius);
            const maxZ = Math.floor(newPos.z + playerRadius);

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        if (isBlockAt(x, y, z)) {
                            return true; 
                        }
                    }
                }
            }
            return false;
        }

        function checkAndApplyMovement() {
            if (isDead) { return; }

            // 1. Apply gravity and update last fall velocity
            if (!player.onGround) {
                player.lastFallVelocity = velocity.y;
                velocity.y = Math.max(-TERMINAL_VELOCITY, velocity.y - GRAVITY);
            }
            
            const delta = velocity.clone();
            const wasOnGround = player.onGround;
            player.onGround = false;

            // 2. Move X axis
            player.position.x += delta.x;
            if (isColliding(player.position)) {
                player.position.x -= delta.x; 
                velocity.x = 0;             
            }

            // 3. Move Y axis
            player.position.y += delta.y;
            if (isColliding(player.position)) {
                
                if (delta.y < 0) {
                    // Landing on floor
                    const minYBlock = Math.floor(player.position.y + playerYOffset);
                    player.position.y = (minYBlock + 1) - playerYOffset + EPSILON; 
                    player.onGround = true; 
                    
                    // --- Fall Damage Check ---
                    if (wasOnGround === false) {
                        // We check the velocity just *before* impact (stored in lastFallVelocity)
                        const impactSpeed = -player.lastFallVelocity; 
                        
                        if (impactSpeed > FALL_DAMAGE_VELOCITY_THRESHOLD) {
                            // Calculate damage (e.g., 1 health damage per 0.1 velocity over threshold)
                            const damage = Math.floor((impactSpeed - FALL_DAMAGE_VELOCITY_THRESHOLD) * FALL_DAMAGE_MULTIPLIER);
                            if (damage > 0) {
                                takeDamage(damage);
                            }
                        }
                        player.lastFallVelocity = 0; // Reset
                    }
                } else { 
                    // Hitting ceiling
                    player.position.y = Math.floor(player.position.y); 
                }
                
                velocity.y = 0;             
            }
            
            // 4. Move Z axis
            player.position.z += delta.z;
            if (isColliding(player.position)) {
                player.position.z -= delta.z; 
                velocity.z = 0;             
            }
        }
        
        // --- Health System Functions ---
        
        function takeDamage(amount) {
            if (isDead) return;
            player.health = Math.max(0, player.health - amount);
            updateHealthDisplay();
            
            if (player.health === 0) {
                die();
            }
        }
        
        function die() {
            isDead = true;
            // Freeze movement
            controls = { forward: 0, backward: 0, left: 0, right: 0, up: false, down: false };
            velocity.set(0, 0, 0);
            
            const msgBox = document.getElementById('message-box');
            document.getElementById('message-title').textContent = "You Died!";
            document.getElementById('message-content').textContent = "You ran out of health. Time to respawn.";
            msgBox.classList.remove('hidden');
        }
        
        function respawn() {
            isDead = false;
            player.health = MAX_HEALTH;
            updateHealthDisplay();
            
            // Move player to a safe start position (spawn point)
            player.position.set(0, getHeight(0, 0) + playerPhysicsHeight + 5, 0); 
            cameraY = player.position.y;
            
            document.getElementById('message-box').classList.add('hidden');
        }
        
        function updateHealthDisplay() {
            const healthBar = document.getElementById('health-bar');
            healthBar.innerHTML = ''; // Clear existing hearts
            
            for (let i = 0; i < MAX_HEALTH / 2; i++) {
                const heart = document.createElement('span');
                heart.classList.add('text-3xl', 'select-none');
                
                let healthForHeart = player.health - (i * 2);
                
                if (healthForHeart >= 2) {
                    // Full Heart (♥)
                    heart.textContent = '♥';
                    heart.style.color = '#ff6b6b'; 
                } else if (healthForHeart === 1) {
                    // Half Heart (using a star/dot as a placeholder, real games use sprites)
                    heart.textContent = '●'; 
                    heart.style.color = '#ffaa6b'; 
                } else {
                    // Empty Heart (♡)
                    heart.textContent = '♡';
                    heart.style.color = '#4a0000';
                }
                healthBar.appendChild(heart);
            }
        }

        // --- Inventory and Hotbar Functions ---

        function updateActiveItem() {
            activeItem = inventory[activeSlotIndex];
            updateHotbarDisplay();
        }

        function addItemToInventory(blockType) {
            // 1. Try to stack in existing slots
            for (let i = 0; i < inventory.length; i++) {
                const slot = inventory[i];
                if (slot.type === blockType && slot.count < 64) {
                    slot.count++;
                    updateHotbarDisplay();
                    return true;
                }
            }

            // 2. Find an empty slot
            for (let i = 0; i < inventory.length; i++) {
                const slot = inventory[i];
                if (slot.type === null) {
                    slot.type = blockType;
                    slot.count = 1;
                    updateHotbarDisplay();
                    return true;
                }
            }
            return false; // Inventory full
        }

        function useActiveItem() {
            if (activeItem.type && activeItem.count > 0) {
                activeItem.count--;
                if (activeItem.count === 0) {
                    activeItem.type = null;
                }
                updateHotbarDisplay();
                return true;
            }
            return false;
        }
        
        function updateHotbarDisplay() {
            const hotbarEl = document.getElementById('hotbar');
            hotbarEl.innerHTML = '';

            inventory.forEach((item, index) => {
                const slotEl = document.createElement('div');
                slotEl.classList.add('hotbar-slot');
                slotEl.dataset.slotIndex = index;

                if (index === activeSlotIndex) {
                    slotEl.classList.add('active');
                }
                
                if (item.type) {
                    // OCCUPIED SLOT: Display color and count
                    
                    // Item Display (Sets the color background)
                    const itemDisplay = document.createElement('div');
                    itemDisplay.classList.add('slot-item-display');
                    // Use the item's iconColor for the slot background
                    itemDisplay.style.backgroundColor = `#${new THREE.Color(item.type.iconColor || 0xffffff).getHexString()}`;
                    
                    // Count Display (Corner Text)
                    const countDisplay = document.createElement('span');
                    countDisplay.classList.add('slot-count');
                    countDisplay.textContent = item.count;
                    
                    // The count element is appended directly to the slot, making its absolute
                    // positioning relative to the whole slot, ensuring it sits in the corner.
                    slotEl.appendChild(itemDisplay);
                    slotEl.appendChild(countDisplay);

                } else {
                    // EMPTY SLOT: Display only the empty slot background (no number, no color)
                    // The .hotbar-slot already provides the base background color
                }

                slotEl.addEventListener('click', () => switchActiveSlot(index));
                hotbarEl.appendChild(slotEl);
            });
        }
        
        function switchActiveSlot(index) {
            if (index < 0 || index >= inventory.length) return;
            activeSlotIndex = index;
            updateActiveItem();
        }

        // --- Block Manipulation (Unchanged) ---
        
        function checkPlayerBlockOverlap(blockX, blockY, blockZ) {
            const playerMinX = player.position.x - playerRadius;
            const playerMaxX = player.position.x + playerRadius;
            const playerMinY = player.position.y + playerYOffset; 
            const playerMaxY = player.position.y;                   
            const playerMinZ = player.position.z - playerRadius;
            const playerMaxZ = player.position.z + playerRadius;

            const blockMinX = blockX;
            const blockMaxX = blockX + 1;
            const blockMinY = blockY;
            const blockMaxY = blockY + 1;
            const blockMinZ = blockZ;
            const blockMaxZ = blockZ + 1;

            const overlapX = (blockMaxX > playerMinX) && (blockMinX < playerMaxX);
            const overlapY = (blockMaxY > playerMinY) && (blockMinY < playerMaxY);
            const overlapZ = (blockMaxZ > playerMinZ) && (blockMinZ < playerMaxZ);

            return overlapX && overlapY && overlapZ;
        }

        function getTargetedBlock() {
            if (!opaqueMesh) return null;

            raycaster.setFromCamera({ x: 0, y: 0 }, camera); 
            
            const intersects = raycaster.intersectObjects([opaqueMesh, ...transparentGroup.children]);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                const x = Math.floor(intersect.point.x - intersect.face.normal.x * 0.01);
                const y = Math.floor(intersect.point.y - intersect.face.normal.y * 0.01);
                const z = Math.floor(intersect.point.z - intersect.face.normal.z * 0.01);

                const normal = intersect.face.normal.clone();

                return { x, y, z, normal, isBlock: true };
            }
            return null;
        }
        
        function mineBlock() {
            if (isDead) return;
            const target = getTargetedBlock();
            if (target && target.isBlock) {
                const key = getKey(target.x, target.y, target.z);
                
                if (worldBlockData.has(key)) {
                    const blockType = worldBlockData.get(key);
                    
                    worldBlockData.delete(key);
                    refreshWorldMesh(); 
                    
                    addItemToInventory(blockType);
                }
            }
        }

        function placeBlock() {
            if (isDead) return;
            // Check if the player has an active item and it's a block
            if (!activeItem.type || activeItem.count === 0) return;
            
            const target = getTargetedBlock();
            if (target) {
                const newX = target.x + Math.round(target.normal.x);
                const newY = target.y + Math.round(target.normal.y);
                const newZ = target.z + Math.round(target.normal.z);

                const newBlockKey = getKey(newX, newY, newZ);
                
                if (checkPlayerBlockOverlap(newX, newY, newZ)) {
                    return; 
                }

                if (!worldBlockData.has(newBlockKey)) {
                    // Place block and consume item
                    worldBlockData.set(newBlockKey, activeItem.type);
                    useActiveItem();
                    refreshWorldMesh(); 
                }
            }
        }

        
        // --- Initialization and Game Loop ---

        function init() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;
            const aspectRatio = containerWidth / containerHeight;
            const loadingScreen = document.getElementById('loading');
            
            loadingScreen.style.display = 'none';
            
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.copy(player.position); 
            cameraY = player.position.y; 

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement); 
            renderer.sortObjects = true;

            // 4. Lighting 
            const ambientLight = new THREE.AmbientLight(0x404040, 3); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; 
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // 5. World Generation
            populateWorldData(); 
            refreshWorldMesh(); 

            // 6. Player Model
            createPlayerModel();

            // 7. Initial Player Setup
            player.position.y = getHeight(0, 0) + playerPhysicsHeight + 2; 
            
            // Give initial items (Survival Start)
            inventory[0] = { type: blockTypes.GRASS, count: 10 };
            inventory[1] = { type: blockTypes.DIRT, count: 10 };
            inventory[2] = { type: blockTypes.STONE, count: 10 };
            updateActiveItem();
            updateHealthDisplay();
            
            // 8. Event Listeners
            window.addEventListener('resize', () => { onWindowResize(); calculateJoystickPosition(); });
            setupInputListeners(container);
            calculateJoystickPosition(); 
            document.getElementById('respawn-btn').addEventListener('click', respawn);

            // 9. Start the game loop
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isDead) {
                renderer.render(scene, camera);
                return;
            }

            // 1. Calculate input force
            const horizontalInputActive = controls.forward > 0 || controls.backward > 0 || controls.left > 0 || controls.right > 0;
            
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const rightVector = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            rightVector.y = 0;
            rightVector.normalize();

            // 2. Set target velocity based on input (Applying Acceleration)
            if (horizontalInputActive) {
                const targetDirection = new THREE.Vector3();
                
                targetDirection.addScaledVector(cameraDirection, (controls.forward - controls.backward));
                targetDirection.addScaledVector(rightVector, (controls.right - controls.left));
                
                if (targetDirection.lengthSq() > 0) {
                    targetDirection.normalize();
                    
                    velocity.x += targetDirection.x * ACCELERATION;
                    velocity.z += targetDirection.z * ACCELERATION;

                    const currentSpeedSq = velocity.x * velocity.x + velocity.z * velocity.z;
                    if (currentSpeedSq > MAX_WALK_SPEED * MAX_WALK_SPEED) {
                        const currentSpeed = Math.sqrt(currentSpeedSq);
                        const scaleFactor = MAX_WALK_SPEED / currentSpeed;
                        velocity.x *= scaleFactor;
                        velocity.z *= scaleFactor;
                    }
                }

            } else if (player.onGround) {
                // Apply friction for smooth deceleration when no keys are pressed
                velocity.x *= FRICTION;
                velocity.z *= FRICTION;
                
                if (Math.abs(velocity.x) < 0.005) velocity.x = 0;
                if (Math.abs(velocity.z) < 0.005) velocity.z = 0;
            }

            // 3. Handle Jump
            if (controls.up && player.onGround) {
                velocity.y = JUMP_VELOCITY;
                player.onGround = false;
                controls.up = false; 
            }

            // 4. Collision Detection and Movement Application
            checkAndApplyMovement();
            
            // 5. Smooth Camera Y Position 
            cameraY = THREE.MathUtils.lerp(cameraY, player.position.y, 0.3);


            // 6. Update Player Model position and rotation
            playerModel.position.x = player.position.x;
            playerModel.position.z = player.position.z;
            playerModel.position.y = player.position.y + playerYOffset; 

            if (horizontalInputActive) {
                const horizontalVelocity = new THREE.Vector2(velocity.x, velocity.z);
                if (horizontalVelocity.lengthSq() > 0.001) { 
                    const angle = Math.atan2(horizontalVelocity.x, horizontalVelocity.z);
                    player.rotationY = angle;
                }
            }
            playerModel.rotation.y = player.rotationY; 

            // 7. Camera View Update
            if (isThirdPerson) {
                const radius = thirdPersonDistance;
                const pitch = cameraLook.pitch;
                const yaw = cameraLook.yaw;
                
                camera.position.x = player.position.x + radius * Math.sin(yaw) * Math.cos(pitch);
                camera.position.y = player.position.y + thirdPersonHeightOffset + radius * Math.sin(pitch);
                camera.position.z = player.position.z + radius * Math.cos(yaw) * Math.cos(pitch);
                
                camera.lookAt(player.position.x, player.position.y + thirdPersonHeightOffset, player.position.z);
                
            } else {
                camera.position.x = player.position.x;
                camera.position.z = player.position.z;
                camera.position.y = cameraY; 
                camera.rotation.set(cameraLook.pitch, cameraLook.yaw, 0, 'YXZ');
            }

            // 8. Rendering
            renderer.render(scene, camera);
        }

        // --- UI and Input Handlers ---
        
        function toggleView() {
            isThirdPerson = !isThirdPerson;
            const button = document.getElementById('view-toggle-btn');
            const crosshair = document.getElementById('crosshair');
            
            playerModel.visible = isThirdPerson;
            
            if (isThirdPerson) {
                button.textContent = 'Toggle View (TP)';
                crosshair.style.display = 'none'; 
                player.rotationY = cameraLook.yaw; 
            } else {
                button.textContent = 'Toggle View (FP)';
                crosshair.style.display = 'block';
            }
        }
        
        function onWindowResize() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;

            camera.aspect = containerWidth / containerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(containerWidth, containerHeight);
        }

        function calculateJoystickPosition() {
            const rect = joystick.base.getBoundingClientRect();
            joystick.baseX = rect.left + joystick.radius;
            joystick.baseY = rect.top + joystick.radius;

            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;
        }

        function updateJoystick(currentX, currentY) {
            const dx = currentX - joystick.baseX;
            const dy = currentY - joystick.baseY;
            let distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let finalX = currentX;
            let finalY = currentY;

            if (distance > joystick.maxDistance) {
                distance = joystick.maxDistance;
                finalX = joystick.baseX + Math.cos(angle) * joystick.maxDistance;
                finalY = joystick.baseY + Math.sin(angle) * joystick.maxDistance;
            } else {
                finalX = currentX;
                finalY = currentY;
            }

            joystick.handle.style.left = `${finalX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${finalY - joystick.radius / 2}px`;

            const magnitude = distance / joystick.maxDistance; 
            const forwardComponent = -Math.sin(angle); 
            const rightComponent = Math.cos(angle); 

            controls.forward = Math.max(0, forwardComponent) * magnitude;
            controls.backward = Math.max(0, -forwardComponent) * magnitude;
            controls.right = Math.max(0, rightComponent) * magnitude;
            controls.left = Math.max(0, -rightComponent) * magnitude;
        }

        function resetJoystick() {
            joystick.active = false;
            joystick.touchId = null;
            joystick.handle.style.opacity = '0';
            
            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;

            controls.forward = controls.backward = controls.left = controls.right = 0;
        }

        function applyLookDelta(deltaX, deltaY, speed) {
            cameraLook.yaw -= deltaX * speed;
            cameraLook.pitch -= deltaY * speed; 
            
            cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraLook.pitch));
        }

        function setupInputListeners(container) {
            const canvasElement = renderer.domElement;
            const containerWidth = container.clientWidth;

            // --- Keyboard Controls (Desktop) ---
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                
                // Hotbar switching 1-9
                const slotIndex = parseInt(e.key) - 1;
                if (slotIndex >= 0 && slotIndex < 9) {
                    switchActiveSlot(slotIndex);
                    e.preventDefault(); 
                }

                if (key === 'w' || key === 'arrowup') controls.forward = 1;
                if (key === 's' || key === 'arrowdown') controls.backward = 1;
                if (key === 'a' || key === 'arrowleft') controls.left = 1;
                if (key === 'd' || key === 'arrowright') controls.right = 1;
                if (key === ' ') controls.up = true; 
                if (key === 'v') toggleView(); 
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') controls.forward = 0;
                if (key === 's' || key === 'arrowdown') controls.backward = 0;
                if (key === 'a' || key === 'arrowleft') controls.left = 0;
                if (key === 'd' || key === 'arrowright') controls.right = 0;
            });

            // --- Mouse/Look & Action Controls (Desktop) ---
            canvasElement.addEventListener('mousedown', (e) => {
                if (isDead) return;

                if (e.pointerType === 'mouse' || container.clientWidth > 768) { 
                    if (e.button === 0) {
                        mineBlock();
                        if (canvasElement.requestPointerLock) {
                            canvasElement.requestPointerLock();
                        }
                    } 
                    else if (e.button === 2) {
                        placeBlock(); 
                    }
                }
            });
            
            canvasElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvasElement && !isDead) { 
                    applyLookDelta(e.movementX, e.movementY, lookSpeed);
                }
            });

            // --- Mobile Touch Controls ---
            
            const isInsideJoystickArea = (clientX, clientY) => {
                const dx = clientX - joystick.baseX;
                const dy = clientY - joystick.baseY;
                return Math.sqrt(dx * dx + dy * dy) <= joystick.radius;
            };

            container.addEventListener('touchstart', (e) => {
                if (isDead) return;

                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (!joystick.active && isInsideJoystickArea(touch.clientX, touch.clientY)) {
                        joystick.active = true;
                        joystick.touchId = touch.identifier;
                        joystick.handle.style.opacity = '1';
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    else if (
                        touch.clientX >= containerWidth / 2 && 
                        !touch.target.closest('#action-buttons') && 
                        !activeLookTouch &&
                        !touch.target.closest('#view-toggle-btn') &&
                        !touch.target.closest('#hotbar')
                    ) {
                        activeLookTouch = {
                            identifier: touch.identifier,
                            prevX: touch.clientX,
                            prevY: touch.clientY
                        };
                    }
                }
            }, { passive: true }); 

            container.addEventListener('touchmove', (e) => {
                if (isDead) return;
                e.preventDefault(); 
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        const deltaX = touch.clientX - activeLookTouch.prevX;
                        const deltaY = touch.clientY - activeLookTouch.prevY;
                        
                        applyLookDelta(deltaX, deltaY, lookSpeed * 5); 
                        
                        activeLookTouch.prevX = touch.clientX; 
                        activeLookTouch.prevY = touch.clientY;
                    }
                }
            }, { passive: false }); 

            container.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        resetJoystick();
                    }
                    
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        activeLookTouch = null;
                    }
                }
            }, { passive: true });
            
            // --- Mobile Action Button Listeners ---
            document.getElementById('mine-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                mineBlock();
            }, { passive: false });

            document.getElementById('place-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                placeBlock();
            }, { passive: false });
            
            document.getElementById('jump-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                controls.up = true; 
            }, { passive: false });
            document.getElementById('jump-btn').addEventListener('pointerup', (e) => {
                e.preventDefault();
                controls.up = false; 
            }, { passive: false });

            document.getElementById('view-toggle-btn').addEventListener('click', toggleView);
        }

        // Start the application after the window loads
        window.onload = init;
    </script>
</body>
</html>
