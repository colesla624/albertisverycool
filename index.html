<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minecraft-like Game with Drag Rotation, Collisions, Build</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }

    /* Buttons */
    .btn {
      padding: 10px 14px;
      background: rgba(30,30,30,0.65);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.35);
      border-radius: 8px;
      font-size: 14px;
      backdrop-filter: blur(4px);
      user-select: none;
      touch-action: manipulation;
    }
    #povBtn { position: absolute; top: 12px; left: 12px; z-index: 10; }

    /* Right-side controls: always visible */
    #uiRight {
      position: absolute;
      right: 14px;
      bottom: 140px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
    }
    #jumpBtn { position: absolute; right: 14px; bottom: 20px; z-index: 10; }

    /* Joystick */
    #joystick {
      position: absolute;
      bottom: 24px;
      left: 24px;
      width: 150px;
      height: 150px;
      background: rgba(200,200,200,0.18);
      border: 2px solid rgba(255,255,255,0.25);
      border-radius: 50%;
      touch-action: none;
      z-index: 10;
    }
    #stick {
      position: absolute;
      width: 68px;
      height: 68px;
      background: rgba(100,100,100,0.65);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      left: 41px; top: 41px;
      touch-action: none;
    }

    /* Crosshair */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px; height: 20px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 5;
    }
    #crosshair::before, #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 0 2px rgba(0,0,0,0.4);
    }
    #crosshair::before { width: 2px; height: 20px; left: 9px; top: 0; }
    #crosshair::after { width: 20px; height: 2px; left: 0; top: 9px; }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <button id="povBtn" class="btn">POV: Third</button>

  <div id="uiRight">
    <button id="placeBtn" class="btn">Place</button>
    <button id="deleteBtn" class="btn">Delete</button>
  </div>
  <button id="jumpBtn" class="btn">Jump</button>

  <div id="joystick"><div id="stick"></div></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    // ------------------------------------------------------------
    // Utilities: seeded 2D noise
    // ------------------------------------------------------------
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }
    function makeNoise2D(seed = 12345) {
      const rand = mulberry32(seed);
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) perm[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 256; i++) perm[256 + i] = perm[i];
      function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
      function lerp(a, b, t) { return a + t * (b - a); }
      function grad(hash, x, y) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
      }
      return function(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x), v = fade(y);
        const aa = perm[X + perm[Y]];
        const ab = perm[X + perm[Y + 1]];
        const ba = perm[X + 1 + perm[Y]];
        const bb = perm[X + 1 + perm[Y + 1]];
        return lerp(lerp(grad(aa, x, y), grad(ba, x - 1, y), u),
                    lerp(grad(ab, x, y - 1), grad(bb, x - 1, y - 1), u), v);
      };
    }

    // ------------------------------------------------------------
    // Three.js setup
    // ------------------------------------------------------------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1200);
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x889988, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(20, 30, 10);
    scene.add(hemi); scene.add(dir);

    // ------------------------------------------------------------
    // Voxel world
    // ------------------------------------------------------------
    const BLOCK_SIZE = 1;
    const WORLD_SIZE = 64;
    const MAX_HEIGHT = 16;

    const matGrass = new THREE.MeshLambertMaterial({ color: 0x3a9d23 });
    const matDirt  = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
    const matStone = new THREE.MeshLambertMaterial({ color: 0x7f7f7f });

    const blockGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    const voxels = new Map(); // "x,y,z" -> mesh
    function key(x,y,z){ return `${x},${y},${z}`; }

    function addBlock(x, y, z, type = "grass") {
      const k = key(x, y, z);
      if (voxels.has(k)) return;
      const mat = type === "stone" ? matStone : (type === "dirt" ? matDirt : matGrass);
      const mesh = new THREE.Mesh(blockGeo, mat);
      mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
      mesh.userData = { x, y, z, type, solid: true };
      scene.add(mesh);
      voxels.set(k, mesh);
    }
    function removeBlock(x, y, z) {
      const k = key(x, y, z);
      const mesh = voxels.get(k);
      if (!mesh) return;
      scene.remove(mesh);
      mesh.geometry.dispose();
      voxels.delete(k);
    }

    // Terrain generation
    const noise = makeNoise2D(1337);
    const SCALE = 0.08;
    for (let x = 0; x < WORLD_SIZE; x++) {
      for (let z = 0; z < WORLD_SIZE; z++) {
        const nx = x * SCALE, nz = z * SCALE;
        const hVal = (noise(nx, nz) * 0.65) + (noise(nx * 0.45, nz * 0.45) * 0.35);
        const height = Math.floor((hVal * 0.5 + 0.5) * MAX_HEIGHT);
        for (let y = 0; y <= height; y++) {
          const type = y === height ? "grass" : (y > height - 3 ? "dirt" : "stone");
          addBlock(x, y, z, type);
        }
      }
    }

    // ------------------------------------------------------------
    // Player
    // ------------------------------------------------------------
    const playerGeo = new THREE.BoxGeometry(0.8, 1.6, 0.8);
    const playerMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
    const player = new THREE.Mesh(playerGeo, playerMat);
    player.position.set(WORLD_SIZE/2 + 0.5, MAX_HEIGHT + 8, WORLD_SIZE/2 + 0.5);
    scene.add(player);

    const PSX = 0.8, PSY = 1.6, PSZ = 0.8; // player AABB size
    const HALF_X = PSX/2, HALF_Y = PSY/2, HALF_Z = PSZ/2;

    const playerVel = new THREE.Vector3(0, 0, 0);
    const GRAVITY = 20;
    const MOVE_SPEED = 4.5;
    const JUMP_SPEED = 8.0;
    let onGround = false;
    let pov = "third";

    // Facing angles via drag
    let yaw = 0;    // rotation around Y
    let pitch = 0;  // rotation around X (camera only, clamped)

    // ------------------------------------------------------------
    // Joystick (inverted forward/backward: up = backward, down = forward)
    // ------------------------------------------------------------
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");
    let joyVec = { x: 0, y: 0 };
    const JOY_RADIUS = 56;
    let joyCenter = null;

    function recalcJoyCenter() {
      const rect = joystick.getBoundingClientRect();
      joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    }
    recalcJoyCenter();
    window.addEventListener('resize', recalcJoyCenter);

    function updateJoystick(e) {
      const t = e.touches[0];
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;
      const dist = Math.min(Math.hypot(dx, dy), JOY_RADIUS);
      const angle = Math.atan2(dy, dx);
      const rawX = Math.cos(angle) * (dist / JOY_RADIUS);
      const rawY = Math.sin(angle) * (dist / JOY_RADIUS);
      joyVec.x = rawX;
      joyVec.y = -rawY; // invert forward/backward
      stick.style.left = (41 + rawX * JOY_RADIUS) + "px";
      stick.style.top  = (41 + rawY * JOY_RADIUS) + "px";
    }
    joystick.addEventListener("touchstart", updateJoystick, { passive: true });
    joystick.addEventListener("touchmove", updateJoystick, { passive: true });
    joystick.addEventListener("touchend", () => {
      joyVec.x = 0; joyVec.y = 0;
      stick.style.left = "41px"; stick.style.top = "41px";
    });

    // ------------------------------------------------------------
    // Finger drag rotation (exclude joystick area)
    // ------------------------------------------------------------
    let dragging = false, lastX = 0, lastY = 0;
    document.addEventListener("touchstart", e => {
      if (e.target.closest("#joystick")) return;
      dragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener("touchmove", e => {
      if (!dragging) return;
      const tx = e.touches[0].clientX;
      const ty = e.touches[0].clientY;
      const dx = tx - lastX;
      const dy = ty - lastY;
      yaw -= dx * 0.005;               // horizontal drag rotates yaw
      pitch -= dy * 0.005;             // vertical drag rotates pitch
      pitch = Math.max(-Math.PI/3, Math.min(Math.PI/3, pitch)); // clamp pitch
      lastX = tx; lastY = ty;
    }, { passive: true });

    document.addEventListener("touchend", () => { dragging = false; }, { passive: true });

    // ------------------------------------------------------------
    // Buttons: POV / Jump / Place / Delete
    // ------------------------------------------------------------
    const povBtn = document.getElementById("povBtn");
    const jumpBtn = document.getElementById("jumpBtn");
    const placeBtn = document.getElementById("placeBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    povBtn.addEventListener("click", () => {
      pov = (pov === "third") ? "first" : "third";
      povBtn.textContent = `POV: ${pov === "third" ? "Third" : "First"}`;
    });

    jumpBtn.addEventListener("click", () => {
      if (onGround) { playerVel.y = JUMP_SPEED; onGround = false; }
    });

    // ------------------------------------------------------------
    // Raycasting for block interactions
    // ------------------------------------------------------------
    const raycaster = new THREE.Raycaster();
    function getCenterRayHit() {
      const ndc = new THREE.Vector2(0, 0); // screen center
      raycaster.setFromCamera(ndc, camera);
      const meshes = Array.from(voxels.values());
      const hits = raycaster.intersectObjects(meshes, false);
      return hits.length ? hits[0] : null;
    }
    function placeBlockAtAim() {
      const hit = getCenterRayHit();
      if (!hit) return;
      const normalWorld = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
      const p = hit.point.clone().addScaledVector(normalWorld, 0.5);
      const gx = Math.floor(p.x), gy = Math.floor(p.y), gz = Math.floor(p.z);
      if (gx < 0 || gz < 0 || gx >= WORLD_SIZE || gz >= WORLD_SIZE || gy < 0 || gy > MAX_HEIGHT + 20) return;
      addBlock(gx, gy, gz, "grass");
    }
    function deleteBlockAtAim() {
      const hit = getCenterRayHit();
      if (!hit) return;
      const { x, y, z } = hit.object.userData;
      removeBlock(x, y, z);
    }
    placeBtn.addEventListener("click", placeBlockAtAim);
    deleteBtn.addEventListener("click", deleteBlockAtAim);

    // ------------------------------------------------------------
    // Collision resolution (voxel AABB)
    // ------------------------------------------------------------
    function aabbIntersect(ax, ay, az, asx, asy, asz, bx, by, bz, bsx, bsy, bsz) {
      return Math.abs(ax - bx) * 2 < (asx + bsx) &&
             Math.abs(ay - by) * 2 < (asy + bsy) &&
             Math.abs(az - bz) * 2 < (asz + bsz);
    }

    function resolveCollisions() {
      const px = player.position.x;
      const py = player.position.y;
      const pz = player.position.z;

      onGround = false;

      const minX = Math.floor(px - 1.5);
      const maxX = Math.floor(px + 1.5);
      const minY = Math.floor(py - 1.2);
      const maxY = Math.floor(py + 1.2);
      const minZ = Math.floor(pz - 1.5);
      const maxZ = Math.floor(pz + 1.5);

      for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
          for (let z = minZ; z <= maxZ; z++) {
            const mesh = voxels.get(key(x, y, z));
            if (!mesh) continue;
            const bx = mesh.position.x;
            const by = mesh.position.y;
            const bz = mesh.position.z;
            const BS = BLOCK_SIZE;

            if (aabbIntersect(px, py, pz, PSX, PSY, PSZ, bx, by, bz, BS, BS, BS)) {
              const penX = (HALF_X + BS/2) - Math.abs(px - bx);
              const penY = (HALF_Y + BS/2) - Math.abs(py - by);
              const penZ = (HALF_Z + BS/2) - Math.abs(pz - bz);

              if (penX < penY && penX < penZ) {
                const sign = (px < bx) ? -1 : 1;
                player.position.x += sign * penX;
                playerVel.x = 0;
              } else if (penY < penX && penY < penZ) {
                const sign = (py < by) ? -1 : 1;
                player.position.y += sign * penY;
                if (sign < 0) onGround = true;   // landed on block
                if (playerVel.y < 0 && sign > 0) playerVel.y = 0; // stop sinking
                if (playerVel.y > 0 && sign < 0) playerVel.y = 0; // ceiling bump
              } else {
                const sign = (pz < bz) ? -1 : 1;
                player.position.z += sign * penZ;
                playerVel.z = 0;
              }
            }
          }
        }
      }

      // Bounds safety
      player.position.x = Math.max(HALF_X, Math.min(WORLD_SIZE - HALF_X, player.position.x));
      player.position.z = Math.max(HALF_Z, Math.min(WORLD_SIZE - HALF_Z, player.position.z));
      if (player.position.y < HALF_Y) {
        player.position.y = HALF_Y;
        playerVel.y = 0;
        onGround = true;
      }
    }

    // ------------------------------------------------------------
    // Camera and facing
    // ------------------------------------------------------------
    function getFacingVectors() {
      const cosY = Math.cos(yaw), sinY = Math.sin(yaw);
      const cosP = Math.cos(pitch), sinP = Math.sin(pitch);

      // Forward vector based on yaw/pitch (y pitch affects look, not movement vertical)
      const forward = new THREE.Vector3(
        -sinY * cosP,
        0,                      // keep movement on XZ plane
        -cosY * cosP
      );
      forward.normalize();

      const right = new THREE.Vector3(cosY, 0, -sinY).normalize();
      return { forward, right };
    }

    function updateCamera() {
      const { forward, right } = getFacingVectors();
      const target = player.position.clone();

      if (pov === "first") {
        const eye = target.clone().add(new THREE.Vector3(0, 0.6, 0));
        camera.position.copy(eye);

        // Look dir uses pitch for aiming
        const lookDir = new THREE.Vector3(
          forward.x,
          Math.sin(pitch),      // vertical aim
          forward.z
        ).normalize();

        const lookTarget = eye.clone().add(lookDir);
        camera.lookAt(lookTarget);
      } else {
        // Third-person: offset back and up relative to facing
        const back = forward.clone().multiplyScalar(-1);
        const camPos = target.clone()
          .add(new THREE.Vector3(0, 3.5, 0))
          .add(back.multiplyScalar(8));
        camera.position.copy(camPos);
        camera.lookAt(target.clone().add(new THREE.Vector3(0, 1.0, 0)));
      }
    }

    // ------------------------------------------------------------
    // Main loop
    // ------------------------------------------------------------
    let lastTime = performance.now();
    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.033);
      lastTime = now;

      // Gravity
      playerVel.y -= GRAVITY * dt;

      // Movement (inverted forward/backward applied already in joyVec)
      const { forward, right } = getFacingVectors();
      const moveDir = new THREE.Vector3()
        .addScaledVector(right, joyVec.x)
        .addScaledVector(forward, joyVec.y);

      if (moveDir.lengthSq() > 0) moveDir.normalize();

      playerVel.x = moveDir.x * MOVE_SPEED;
      playerVel.z = moveDir.z * MOVE_SPEED;

      // Integrate velocity
      player.position.x += playerVel.x * dt;
      player.position.y += playerVel.y * dt;
      player.position.z += playerVel.z * dt;

      // Collisions
      resolveCollisions();

      // Camera
      updateCamera();

      renderer.render(scene, camera);
    }
    animate();

    // ------------------------------------------------------------
    // Resize
    // ------------------------------------------------------------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      recalcJoyCenter();
    });

    // ------------------------------------------------------------
    // Desktop fallbacks (WASD + Space) mirroring joystick inversion
    // ------------------------------------------------------------
    const keys = new Set();
    window.addEventListener('keydown', e => {
      keys.add(e.code);
      if (e.code === "Space") jumpBtn.click();
    });
    window.addEventListener('keyup', e => keys.delete(e.code));

    function desktopControlsToJoystick() {
      let x = 0, y = 0;
      if (keys.has("KeyA")) x -= 1;
      if (keys.has("KeyD")) x += 1;
      if (keys.has("KeyW")) y += 1;  // W = backward (inverted)
      if (keys.has("KeyS")) y -= 1;  // S = forward
      const len = Math.hypot(x, y);
      if (len > 0) { x /= len; y /= len; }
      joyVec.x = x; joyVec.y = y;

      // Visual stick follows desktop input (invert display back to raw)
      stick.style.left = (41 + x * JOY_RADIUS) + "px";
      stick.style.top  = (41 + (-y) * JOY_RADIUS) + "px";
      requestAnimationFrame(desktopControlsToJoystick);
    }
    desktopControlsToJoystick();
  </script>
</body>
</html>
