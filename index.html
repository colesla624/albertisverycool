<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Builder Game - High Friction (Snappy Stop)</title>
    <!-- Load Tailwind CSS for easy UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom CSS for the canvas and overall layout */
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Prevents default browser touch actions */
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }

        /* Action button refinement */
        .action-btn {
            @apply shadow-2xl transition transform active:scale-95 text-white font-bold rounded-full;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
            -webkit-tap-highlight-color: transparent;
        }

        /* Fixed Joystick Base Styles */
        #joystick-base {
            position: absolute;
            bottom: 30px; 
            left: 30px; 
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            z-index: 50;
            opacity: 0.8; 
        }

        /* Joystick Handle Styles (will move) */
        #joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            z-index: 60;
            opacity: 0; 
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 3D Canvas will be injected here -->
        <div id="crosshair"></div>

        <!-- Inventory/HUD -->
        <div id="hud" class="absolute top-4 left-1/2 transform -translate-x-1/2 p-2 bg-gray-900 bg-opacity-70 rounded-xl shadow-lg z-20 flex space-x-4">
            <div id="active-block" class="p-2 border-2 border-green-400 rounded-lg text-white font-bold cursor-pointer hover:bg-gray-700 transition">
                Active: Wood
            </div>
            <div id="action-tip" class="p-2 text-sm text-gray-300 hidden sm:block">
                WASD/Arrows to Move | Click to Lock Mouse & Look | Right-Click to Place
            </div>
        </div>
        
        <!-- View Toggle Button -->
        <button id="view-toggle-btn" class="absolute top-4 right-4 action-btn bg-purple-500 hover:bg-purple-600 active:bg-purple-700 p-3 text-sm z-30 w-32 h-12">
            Toggle View (FP)
        </button>


        <!-- Fixed Joystick Base (Mobile) -->
        <div id="joystick-base"></div>
        <!-- Dynamic Joystick Handle (Mobile) -->
        <div id="joystick-handle"></div>

        <!-- Mobile Action Buttons (Right Side) -->
        <div id="action-buttons" class="absolute bottom-6 right-6 flex flex-col space-y-4 z-20">
            <!-- Jump Button -->
            <button id="jump-btn" class="action-btn w-16 h-16 bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-3xl">
                â†‘
            </button>
            <!-- Place Block -->
            <button id="place-btn" class="action-btn w-16 h-16 bg-green-500 hover:bg-green-600 active:bg-green-700 text-4xl">
                +
            </button>
            <!-- Mine Block -->
            <button id="mine-btn" class="action-btn w-16 h-16 bg-red-500 hover:bg-red-600 active:bg-red-700 text-4xl">
                -
            </button>
        </div>

    </div>

    <script type="module">
        // --- Core Global Variables ---
        let scene, camera, renderer;
        let playerModel; 
        let worldMesh; 
        
        // Block data storage: key -> blockType (used for collision and world generation)
        const worldBlockData = new Map(); 
        
        // --- Physics & Player Constants ---
        const GRAVITY = 0.0185;         
        const TERMINAL_VELOCITY = 0.5;  
        const JUMP_VELOCITY = 0.2;    
        
        // --- Movement Constants for Acceleration ---
        const MAX_WALK_SPEED = 0.20;    // Maximum speed the player can reach
        const ACCELERATION = 0.008;     // Rate at which velocity increases
        const FRICTION = 0.4;           // <<<<<<<< UPDATED: Rate at which velocity decreases (low value = snappy stop)
        
        // Player's velocity vector (how much the player moves each frame)
        let velocity = new THREE.Vector3(0, 0, 0); 
        
        // Player Collision Box (AABB)
        const playerHeight = 1.8;
        const playerRadius = 0.3; // Half width/depth of the AABB
        const playerYOffset = -1.7; // Head position (player.position.y) to feet
        
        // Player state and constants
        const player = {
            position: new THREE.Vector3(0, 10, 0), 
            rotationY: 0, 
            onGround: false,
        };
        const lookSpeed = 0.003; 

        // World Generation Constants
        const WORLD_SIZE = 64; 
        const MAX_HEIGHT = 16;
        
        // Block Definitions (Materials and properties)
        const blockTypes = {
            GRASS: { name: 'Grass', color: 0x4CAF50 },
            DIRT: { name: 'Dirt', color: 0x795548 },
            STONE: { name: 'Stone', color: 0x78909C },
            WOOD: { name: 'Wood', color: 0x8D6E63 },
        };
        let activeBlockType = blockTypes.WOOD;
        
        // Standard block geometry (1 unit cube)
        const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
        
        // Faces used for generating the merged mesh
        const CUBE_FACES = [
            { dir: [1, 0, 0], face: 0, normal: [1, 0, 0] },  
            { dir: [-1, 0, 0], face: 1, normal: [-1, 0, 0] }, 
            { dir: [0, 1, 0], face: 2, normal: [0, 1, 0] },  
            { dir: [0, -1, 0], face: 3, normal: [0, -1, 0] }, 
            { dir: [0, 0, 1], face: 4, normal: [0, 0, 1] },  
            { dir: [0, 0, -1], face: 5, normal: [0, 0, -1] } 
        ];
        
        // --- Control Variables ---
        let controls = { forward: 0, backward: 0, left: 0, right: 0, up: false, down: false };
        let isThirdPerson = false;
        const thirdPersonDistance = 3.5; 
        const thirdPersonHeightOffset = 1.0; 
        const cameraLook = { yaw: 0, pitch: 0 };
        const joystick = { active: false, touchId: null, base: document.getElementById('joystick-base'), handle: document.getElementById('joystick-handle'), baseX: 0, baseY: 0, radius: 60, maxDistance: 40 };
        let activeLookTouch = null; 

        // --- Three.js Setup and Helpers ---
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 10);

        function getKey(x, y, z) {
            return `${x},${y},${z}`;
        }
        
        function isBlockAt(x, y, z) {
            return worldBlockData.has(getKey(Math.floor(x), Math.floor(y), Math.floor(z)));
        }

        /**
         * Creates a capsule geometry for the player model.
         */
        function createCapsuleGeometry(radius, height, radialSegments) {
            const cylinderHeight = height - (2 * radius);
            const material = new THREE.MeshStandardMaterial({ color: 0x33AFFF });
            
            const cylinder = new THREE.CylinderGeometry(radius, radius, cylinderHeight, radialSegments, 1);
            const cylinderMesh = new THREE.Mesh(cylinder, material);
            
            const topSphere = new THREE.SphereGeometry(radius, radialSegments, radialSegments / 2);
            const topMesh = new THREE.Mesh(topSphere, material);
            topMesh.position.y = cylinderHeight / 2;

            const bottomSphere = new THREE.SphereGeometry(radius, radialSegments, radialSegments / 2);
            const bottomMesh = new THREE.Mesh(bottomSphere, material);
            bottomMesh.position.y = -cylinderHeight / 2;
            
            const group = new THREE.Group();
            group.add(cylinderMesh, topMesh, bottomMesh);
            
            // This is the required offset to align the capsule's 'feet' with the origin (0, 0, 0) of the collision box.
            group.traverse((child) => {
                if (child.isMesh) {
                    child.position.y += (height / 2) - radius; 
                }
            });
            
            return group; 
        }

        /**
         * Creates and initializes the player visualization model.
         */
        function createPlayerModel() {
            playerModel = new THREE.Group();
            const capsuleVisual = createCapsuleGeometry(playerRadius, playerHeight, 16);
            
            // Shift the visual model down 1.4 units relative to the head position (player.position) 
            // to align the capsule base with the ground/collision box feet.
            capsuleVisual.position.y = -1.4; 

            playerModel.add(capsuleVisual);
            
            playerModel.position.copy(player.position);
            playerModel.visible = isThirdPerson; 
            scene.add(playerModel);
        }

        // --- World Generation and Optimization (Unchanged) ---
        
        function getHeight(x, z) {
            const baseHeight = 4;
            const lowFreqNoise = Math.sin(x * 0.05) * 5 + Math.cos(z * 0.05) * 5;
            const highFreqNoise = Math.sin(x * 0.2) * 2 + Math.cos(z * 0.2) * 2;
            
            let height = Math.floor(baseHeight + lowFreqNoise + highFreqNoise); 
            height = Math.max(1, Math.min(MAX_HEIGHT, height)); 
            return height;
        }

        function populateWorldData() {
            worldBlockData.clear();
            const offset = Math.floor(WORLD_SIZE / 2);

            for (let x = -offset; x <= offset; x++) {
                for (let z = -offset; z <= offset; z++) {
                    
                    const groundHeight = getHeight(x, z); 
                    
                    for (let y = 0; y < groundHeight; y++) {
                        let type;
                        if (y === groundHeight - 1) {
                            type = blockTypes.GRASS; 
                        } else if (y >= groundHeight - 4) {
                            type = blockTypes.DIRT; 
                        } else {
                            type = blockTypes.STONE; 
                        }
                        worldBlockData.set(getKey(x, y, z), type);
                    }
                }
            }
        }

        function generateStaticGroundMesh() {
            const positions = [];
            const colors = [];
            const normals = [];

            const tempBoxGeometry = blockGeometry.clone();

            worldBlockData.forEach((type, key) => {
                const [x, y, z] = key.split(',').map(Number);
                const blockColor = new THREE.Color(type.color);
                
                CUBE_FACES.forEach(face => {
                    const nx = x + face.dir[0];
                    const ny = y + face.dir[1];
                    const nz = z + face.dir[2];

                    if (!isBlockAt(nx, ny, nz)) {
                        tempBoxGeometry.translate(x + 0.5, y + 0.5, z + 0.5);
                        
                        const positionAttribute = tempBoxGeometry.attributes.position;
                        const indexAttribute = tempBoxGeometry.index;
                        
                        const startIndex = face.face * 6; 
                        
                        for (let i = 0; i < 6; i++) {
                            const vertexIndex = indexAttribute.getX(startIndex + i);
                            
                            positions.push(positionAttribute.getX(vertexIndex), positionAttribute.getY(vertexIndex), positionAttribute.getZ(vertexIndex));
                            normals.push(face.normal[0], face.normal[1], face.normal[2]);
                            colors.push(blockColor.r, blockColor.g, blockColor.b);
                        }

                        tempBoxGeometry.translate(-(x + 0.5), -(y + 0.5), -(z + 0.5));
                    }
                });
            });
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3)); 

            const material = new THREE.MeshPhongMaterial({ 
                vertexColors: true, 
                shininess: 0 
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData.isWorld = true; 
            
            return mesh;
        }

        function refreshWorldMesh() {
            if (worldMesh) {
                scene.remove(worldMesh);
                worldMesh.geometry.dispose();
            }
            worldMesh = generateStaticGroundMesh();
            scene.add(worldMesh);
        }
        
        // --- Collision and Movement Logic (Unchanged) ---
        
        function isColliding(newPos) {
            const minX = Math.floor(newPos.x - playerRadius);
            const maxX = Math.floor(newPos.x + playerRadius);
            
            const minY = Math.floor(newPos.y + playerYOffset);
            const maxY = Math.floor(newPos.y); 

            const minZ = Math.floor(newPos.z - playerRadius);
            const maxZ = Math.floor(newPos.z + playerRadius);

            for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                    for (let z = minZ; z <= maxZ; z++) {
                        if (isBlockAt(x, y, z)) {
                            return true; 
                        }
                    }
                }
            }
            return false;
        }

        /**
         * Collision resolution, now robustly preventing bounce or jitter on landing.
         */
        function checkAndApplyMovement() {
            // 1. Apply gravity
            if (!player.onGround) {
                velocity.y = Math.max(-TERMINAL_VELOCITY, velocity.y - GRAVITY);
            }
            
            const delta = velocity.clone();

            player.onGround = false;

            // 2. Move X axis
            player.position.x += delta.x;
            if (isColliding(player.position)) {
                player.position.x -= delta.x; 
                velocity.x = 0;             
            }

            // 3. Move Y axis (Refactored for non-bouncy landing)
            player.position.y += delta.y;
            if (isColliding(player.position)) {
                
                if (delta.y < 0) {
                    // Landing on floor: SNAP the position exactly to the top surface.
                    const minYBlock = Math.floor(player.position.y + playerYOffset);
                    player.position.y = (minYBlock + 1) - playerYOffset; 
                    player.onGround = true; 
                } else {
                    // Hitting ceiling (delta.y > 0): Rollback the movement.
                    player.position.y -= delta.y; 
                }
                
                // Set velocity to zero for all Y-collisions (no bounce)
                velocity.y = 0;             
            }
            
            // 4. Move Z axis
            player.position.z += delta.z;
            if (isColliding(player.position)) {
                player.position.z -= delta.z; 
                velocity.z = 0;             
            }
        }
        
        // --- Block Manipulation (Unchanged) ---
        
        function mineBlock() {
            const target = getTargetedBlock();
            if (target) {
                const key = getKey(target.x, target.y, target.z);
                
                if (worldBlockData.has(key)) {
                    worldBlockData.delete(key);
                    refreshWorldMesh(); 
                }
            }
        }

        function placeBlock() {
            const target = getTargetedBlock();
            if (target) {
                const newX = target.x + Math.round(target.normal.x);
                const newY = target.y + Math.round(target.normal.y);
                const newZ = target.z + Math.round(target.normal.z);

                const newBlockKey = getKey(newX, newY, newZ);
                
                const testPos = new THREE.Vector3(newX + 0.5, newY + playerHeight, newZ + 0.5); 
                
                // Check if the new block placement intersects with the player's current position
                if (isColliding(testPos)) {
                    return; 
                }

                if (!worldBlockData.has(newBlockKey)) {
                    worldBlockData.set(newBlockKey, activeBlockType);
                    refreshWorldMesh(); 
                }
            }
        }

        function getTargetedBlock() {
            if (!worldMesh) return null;

            raycaster.setFromCamera({ x: 0, y: 0 }, camera); 
            const intersects = raycaster.intersectObject(worldMesh);

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                const x = Math.floor(intersect.point.x - intersect.face.normal.x * 0.01);
                const y = Math.floor(intersect.point.y - intersect.face.normal.y * 0.01);
                const z = Math.floor(intersect.point.z - intersect.face.normal.z * 0.01);

                const normal = intersect.face.normal.clone();

                return { x, y, z, normal };
            }
            return null;
        }
        
        // --- Initialization and Game Loop ---

        function init() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;
            const aspectRatio = containerWidth / containerHeight;

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.copy(player.position); 

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement); 

            // 4. Lighting 
            const ambientLight = new THREE.AmbientLight(0x404040, 3); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; 
            directionalLight.shadow.camera.near = 0.5; directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20; directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20; directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);

            // 5. World Generation
            populateWorldData(); 
            refreshWorldMesh(); 

            // 6. Player Model
            createPlayerModel();

            // 7. Event Listeners
            window.addEventListener('resize', () => { onWindowResize(); calculateJoystickPosition(); });
            setupInputListeners(container);
            calculateJoystickPosition(); 
            updateActiveBlockDisplay();

            // 8. Find a safe starting position above the generated terrain
            player.position.y = getHeight(0, 0) + playerHeight + 2; 

            // 9. Start the game loop
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. Calculate input force
            const horizontalInputActive = controls.forward > 0 || controls.backward > 0 || controls.left > 0 || controls.right > 0;
            
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            cameraDirection.y = 0;
            cameraDirection.normalize();

            const rightVector = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            rightVector.y = 0;
            rightVector.normalize();

            // 2. Set target velocity based on input (Applying Acceleration)
            if (horizontalInputActive) {
                const targetDirection = new THREE.Vector3();
                
                targetDirection.addScaledVector(cameraDirection, (controls.forward - controls.backward));
                targetDirection.addScaledVector(rightVector, (controls.right - controls.left));
                
                if (targetDirection.lengthSq() > 0) {
                    targetDirection.normalize();
                    
                    // Apply acceleration (always pushes velocity toward target direction)
                    velocity.x += targetDirection.x * ACCELERATION;
                    velocity.z += targetDirection.z * ACCELERATION;

                    // Cap speed at MAX_WALK_SPEED
                    const currentSpeedSq = velocity.x * velocity.x + velocity.z * velocity.z;
                    if (currentSpeedSq > MAX_WALK_SPEED * MAX_WALK_SPEED) {
                        const currentSpeed = Math.sqrt(currentSpeedSq);
                        const scaleFactor = MAX_WALK_SPEED / currentSpeed;
                        velocity.x *= scaleFactor;
                        velocity.z *= scaleFactor;
                    }
                }

            } else if (player.onGround) {
                // Apply friction for smooth deceleration when no keys are pressed
                velocity.x *= FRICTION;
                velocity.z *= FRICTION;
                
                // Stop completely when velocity is near zero
                if (Math.abs(velocity.x) < 0.005) velocity.x = 0;
                if (Math.abs(velocity.z) < 0.005) velocity.z = 0;
            }

            // 3. Handle Jump
            if (controls.up && player.onGround) {
                velocity.y = JUMP_VELOCITY;
                player.onGround = false;
                controls.up = false; 
            }

            // 4. Collision Detection and Movement Application
            checkAndApplyMovement();


            // 5. Update Player Model position and rotation
            playerModel.position.copy(player.position);
            if (horizontalInputActive) {
                const horizontalVelocity = new THREE.Vector2(velocity.x, velocity.z);
                if (horizontalVelocity.lengthSq() > 0.001) { 
                    const angle = Math.atan2(horizontalVelocity.x, horizontalVelocity.y);
                    player.rotationY = angle;
                }
            }
            playerModel.rotation.y = player.rotationY; 

            // 6. Camera View Update
            if (isThirdPerson) {
                const radius = thirdPersonDistance;
                const pitch = cameraLook.pitch;
                const yaw = cameraLook.yaw;
                
                camera.position.x = player.position.x + radius * Math.sin(yaw) * Math.cos(pitch);
                camera.position.y = player.position.y + thirdPersonHeightOffset + radius * Math.sin(pitch);
                camera.position.z = player.position.z + radius * Math.cos(yaw) * Math.cos(pitch);
                
                camera.lookAt(player.position.x, player.position.y + thirdPersonHeightOffset, player.position.z);
                
            } else {
                camera.position.copy(player.position);
                camera.rotation.set(cameraLook.pitch, cameraLook.yaw, 0, 'YXZ');
            }

            // 7. Rendering
            renderer.render(scene, camera);
        }

        // --- UI and Input Handlers ---
        
        function toggleView() {
            isThirdPerson = !isThirdPerson;
            const button = document.getElementById('view-toggle-btn');
            const crosshair = document.getElementById('crosshair');
            
            playerModel.visible = isThirdPerson;
            
            if (isThirdPerson) {
                button.textContent = 'Toggle View (TP)';
                crosshair.style.display = 'none'; 
                player.rotationY = cameraLook.yaw; 
            } else {
                button.textContent = 'Toggle View (FP)';
                crosshair.style.display = 'block';
            }
        }
        
        function onWindowResize() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;

            camera.aspect = containerWidth / containerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(containerWidth, containerHeight);
        }

        function calculateJoystickPosition() {
            const rect = joystick.base.getBoundingClientRect();
            joystick.baseX = rect.left + joystick.radius;
            joystick.baseY = rect.top + joystick.radius;

            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;
        }

        function updateJoystick(currentX, currentY) {
            const dx = currentX - joystick.baseX;
            const dy = currentY - joystick.baseY;
            let distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let finalX = currentX;
            let finalY = currentY;

            if (distance > joystick.maxDistance) {
                distance = joystick.maxDistance;
                finalX = joystick.baseX + Math.cos(angle) * joystick.maxDistance;
                finalY = joystick.baseY + Math.sin(angle) * joystick.maxDistance;
            } else {
                finalX = currentX;
                finalY = currentY;
            }

            joystick.handle.style.left = `${finalX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${finalY - joystick.radius / 2}px`;

            const magnitude = distance / joystick.maxDistance; 
            const forwardComponent = -Math.sin(angle); 
            const rightComponent = Math.cos(angle); 

            controls.forward = Math.max(0, forwardComponent) * magnitude;
            controls.backward = Math.max(0, -forwardComponent) * magnitude;
            controls.right = Math.max(0, rightComponent) * magnitude;
            controls.left = Math.max(0, -rightComponent) * magnitude;
        }

        function resetJoystick() {
            joystick.active = false;
            joystick.touchId = null;
            joystick.handle.style.opacity = '0';
            
            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;

            controls.forward = controls.backward = controls.left = controls.right = 0;
        }

        function applyLookDelta(deltaX, deltaY, speed) {
            cameraLook.yaw -= deltaX * speed;
            // Standard vertical look (Up swipe = Up view)
            cameraLook.pitch -= deltaY * speed; 
            
            cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraLook.pitch));
        }

        function setupInputListeners(container) {
            const canvasElement = renderer.domElement;
            const containerWidth = container.clientWidth;

            // --- Keyboard Controls (Desktop) ---
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') controls.forward = 1;
                if (key === 's' || key === 'arrowdown') controls.backward = 1;
                if (key === 'a' || key === 'arrowleft') controls.left = 1;
                if (key === 'd' || key === 'arrowright') controls.right = 1;
                if (key === ' ') controls.up = true; 
                if (key === 'v') toggleView(); 
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') controls.forward = 0;
                if (key === 's' || key === 'arrowdown') controls.backward = 0;
                if (key === 'a' || key === 'arrowleft') controls.left = 0;
                if (key === 'd' || key === 'arrowright') controls.right = 0;
            });

            // --- Mouse/Look & Action Controls (Desktop) ---
            canvasElement.addEventListener('mousedown', (e) => {
                if (e.pointerType === 'mouse' || container.clientWidth > 768) { 
                    if (e.button === 0) {
                        mineBlock();
                        if (canvasElement.requestPointerLock) {
                            canvasElement.requestPointerLock();
                        }
                    } 
                    else if (e.button === 2) {
                        placeBlock(); 
                    }
                }
            });
            
            canvasElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvasElement) { 
                    applyLookDelta(e.movementX, e.movementY, lookSpeed);
                }
            });

            // --- Mobile Touch Controls (Joystick & Look Pad) ---
            
            const isInsideJoystickArea = (clientX, clientY) => {
                const dx = clientX - joystick.baseX;
                const dy = clientY - joystick.baseY;
                return Math.sqrt(dx * dx + dy * dy) <= joystick.radius;
            };

            container.addEventListener('touchstart', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (!joystick.active && isInsideJoystickArea(touch.clientX, touch.clientY)) {
                        joystick.active = true;
                        joystick.touchId = touch.identifier;
                        joystick.handle.style.opacity = '1';
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    else if (
                        touch.clientX >= containerWidth / 2 && 
                        !touch.target.closest('#action-buttons') && 
                        !activeLookTouch &&
                        !touch.target.closest('#view-toggle-btn')
                    ) {
                        activeLookTouch = {
                            identifier: touch.identifier,
                            prevX: touch.clientX,
                            prevY: touch.clientY
                        };
                    }
                }
            }, { passive: true }); 

            container.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        const deltaX = touch.clientX - activeLookTouch.prevX;
                        const deltaY = touch.clientY - activeLookTouch.prevY;
                        
                        applyLookDelta(deltaX, deltaY, lookSpeed * 5); 
                        
                        activeLookTouch.prevX = touch.clientX; 
                        activeLookTouch.prevY = touch.clientY;
                    }
                }
            }, { passive: false }); 

            container.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        resetJoystick();
                    }
                    
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        activeLookTouch = null;
                    }
                }
            }, { passive: true });
            
            // --- Mobile Action Button Listeners ---
            document.getElementById('mine-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                mineBlock();
            }, { passive: false });

            document.getElementById('place-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                placeBlock();
            }, { passive: false });
            
            document.getElementById('jump-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                controls.up = true; 
            }, { passive: false });
            document.getElementById('jump-btn').addEventListener('pointerup', (e) => {
                e.preventDefault();
                controls.up = false; 
            }, { passive: false });

            document.getElementById('view-toggle-btn').addEventListener('click', toggleView);

            document.getElementById('active-block').addEventListener('click', cycleActiveBlock);
        }

        function cycleActiveBlock() {
            const typesArray = Object.values(blockTypes);
            let currentIndex = typesArray.findIndex(type => type.name === activeBlockType.name);
            currentIndex = (currentIndex + 1) % typesArray.length;
            activeBlockType = typesArray[currentIndex];
            updateActiveBlockDisplay();
        }

        function updateActiveBlockDisplay() {
            const display = document.getElementById('active-block');
            display.textContent = `Active: ${activeBlockType.name}`;
            display.style.borderColor = `#${activeBlockType.color.toString(16).padStart(6, '0')}`;
        }


        // Start the application after the window loads
        window.onload = init;
    </script>
</body>
</html>
