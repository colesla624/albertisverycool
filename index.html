<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minecraft-like — Full build (~1000 lines), joystick movement, instanced chunks, closable settings, smaller tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    /* ===============================================================================================
       Base theme and global layout
    =============================================================================================== */
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b1b2b;
      color: #e6f3ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas { display: block; }

    /* ===============================================================================================
       Interactive buttons
    =============================================================================================== */
    .btn {
      padding: 10px 14px;
      background: rgba(30,30,30,0.65);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.35);
      border-radius: 8px;
      font-size: 14px;
      backdrop-filter: blur(4px);
      user-select: none;
      touch-action: manipulation;
      cursor: pointer;
    }
    .btn:hover { filter: brightness(1.08); }
    #povBtn { position: absolute; top: 12px; left: 12px; z-index: 10; }

    #uiRight {
      position: absolute;
      right: 14px;
      bottom: 160px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
    }
    #jumpBtn { position: absolute; right: 14px; bottom: 20px; z-index: 10; }

    /* ===============================================================================================
       Crosshair (center of screen)
    =============================================================================================== */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px; height: 20px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 5;
      opacity: 0.9;
    }
    #crosshair::before, #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 0 2px rgba(0,0,0,0.4);
    }
    #crosshair::before { width: 2px; height: 20px; left: 9px; top: 0; }
    #crosshair::after  { width: 20px; height: 2px; left: 0; top: 9px; }

    /* ===============================================================================================
       Touch joystick (left-bottom)
    =============================================================================================== */
    #joystick {
      position: absolute;
      bottom: 24px;
      left: 24px;
      width: 150px;
      height: 150px;
      background: rgba(200,200,200,0.18);
      border: 2px solid rgba(255,255,255,0.25);
      border-radius: 50%;
      touch-action: none;
      z-index: 10;
    }
    #stick {
      position: absolute;
      width: 68px;
      height: 68px;
      background: rgba(100,100,100,0.65);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      left: 41px; top: 41px;
      touch-action: none;
    }

    /* ===============================================================================================
       Closable settings panel
       - Per request: add button to close panel
       - No top-right stats HUD
    =============================================================================================== */
    #panel {
      position: absolute;
      left: 12px;
      bottom: 200px;
      z-index: 10;
      width: 300px;
      max-width: calc(100vw - 24px);
      background: rgba(10, 18, 28, 0.75);
      color: #e6f3ff;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 10px;
      padding: 12px;
      backdrop-filter: blur(6px);
    }
    #panel h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: #a8d0ff;
    }
    #panel .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: 8px 0;
    }
    #panel input[type="range"] { width: 165px; }
    #panel .small { font-size: 12px; opacity: 0.9; }
    #panel .mono  { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    #panelButtons {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    /* ===============================================================================================
       Minimap (player tracker) — smaller per request
    =============================================================================================== */
    #minimap {
      position: absolute;
      right: 14px;
      top: 70px;
      width: 120px; /* smaller tracker */
      height: 120px; /* smaller tracker */
      z-index: 10;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      backdrop-filter: blur(4px);
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    #minimap canvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      border-radius: 8px;
    }

    /* ===============================================================================================
       Helper tip
    =============================================================================================== */
    .tip {
      position: absolute;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.45);
      color: #e6f3ff;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      z-index: 10;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <!-- =============================================================================================
       UI elements
  ============================================================================================= -->
  <div id="crosshair"></div>

  <button id="povBtn" class="btn">POV: Third</button>

  <div id="uiRight">
    <button id="placeBtn" class="btn">Place</button>
    <button id="deleteBtn" class="btn">Delete</button>
    <button id="reseedBtn" class="btn">Reseed</button>
  </div>

  <button id="jumpBtn" class="btn">Jump</button>

  <div id="joystick"><div id="stick"></div></div>

  <div id="panel">
    <h3>Settings</h3>

    <div class="row">
      <span class="small">View radius (chunks)</span>
      <input type="range" id="viewRadiusSlider" min="2" max="10" step="1" value="5"/>
      <span id="viewRadiusLabel" class="mono small">5</span>
    </div>

    <div class="row">
      <span class="small">Chunk size (blocks)</span>
      <input type="range" id="chunkSizeSlider" min="8" max="24" step="1" value="12"/>
      <span id="chunkSizeLabel" class="mono small">12</span>
    </div>

    <div class="row">
      <span class="small">Max height</span>
      <input type="range" id="heightSlider" min="12" max="40" step="1" value="22"/>
      <span id="heightLabel" class="mono small">22</span>
    </div>

    <div class="row">
      <span class="small">Fog distance</span>
      <input type="range" id="fogSlider" min="200" max="1200" step="50" value="700"/>
      <span id="fogLabel" class="mono small">700</span>
    </div>

    <div class="row">
      <span class="small">Antialias</span>
      <input type="checkbox" id="aaToggle" checked />
    </div>

    <div class="row">
      <span class="small">Shadows</span>
      <input type="checkbox" id="shadowToggle" />
    </div>

    <div class="row">
      <span class="small">Show minimap</span>
      <input type="checkbox" id="minimapToggle" checked />
    </div>

    <div id="panelButtons">
      <button id="closePanelBtn" class="btn">Close settings</button>
      <button id="openPanelBtn" class="btn" style="display:none">Open settings</button>
    </div>
  </div>

  <div id="minimap"><canvas id="minimapCanvas" width="120" height="120"></canvas></div>

  <div class="tip">Double-click the game to enable mouse look. Use the left joystick to move. Drag anywhere else to rotate.</div>

  <!-- =============================================================================================
       Scripts
  ============================================================================================= -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    /* =============================================================================================
       Utilities: seeded noise and math helpers
    ============================================================================================= */
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function makeNoise2D(seed = 1337) {
      const rand = mulberry32(seed);
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) perm[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 256; i++) perm[256 + i] = perm[i];
      function fade(t){ return t*t*t*(t*(t*6-15)+10); }
      function lerp(a,b,t){ return a + t*(b-a); }
      function grad(hash,x,y){
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
      }
      return function(x,y){
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x), v = fade(y);
        const aa = perm[X + perm[Y]];
        const ab = perm[X + perm[Y + 1]];
        const ba = perm[X + 1 + perm[Y]];
        const bb = perm[X + 1 + perm[Y + 1]];
        return lerp(lerp(grad(aa,x,y),grad(ba,x-1,y),u), lerp(grad(ab,x,y-1),grad(bb,x-1,y-1),u), v);
      };
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    /* =============================================================================================
       Scene, camera, renderer
    ============================================================================================= */
    let ANTIALIAS = true;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1600);
    let renderer = new THREE.WebGLRenderer({ antialias: ANTIALIAS, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x889988, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.0); // disabled by default; toggled via settings
    dir.position.set(20, 30, 10);
    scene.add(hemi); scene.add(dir);

    /* =============================================================================================
       World parameters and materials
    ============================================================================================= */
    let WORLD_SIZE = 320;   // square world size in blocks
    let MAX_HEIGHT = 22;    // max terrain height
    let CHUNK_SIZE = 12;    // blocks per chunk side
    let VIEW_RADIUS = 5;    // chunk radius around player
    let SEED = 1337;        // initial seed

    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    const matGrass = new THREE.MeshLambertMaterial({ color: 0x3a9d23 });
    const matDirt  = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
    const matStone = new THREE.MeshLambertMaterial({ color: 0x7f7f7f });

    /* =============================================================================================
       World storage and terrain generation (sparse map)
    ============================================================================================= */
    let noise = makeNoise2D(SEED);
    let SCALE = 0.06;

    const world = new Map(); // key "x,y,z" -> type
    function K(x,y,z){ return `${x},${y},${z}`; }
    function getBlock(x,y,z){ return world.get(K(x,y,z)); }
    function setBlock(x,y,z,type){ world.set(K(x,y,z), type); }
    function clearBlock(x,y,z){ world.delete(K(x,y,z)); }

    function generateTerrain() {
      world.clear();
      for (let x = 0; x < WORLD_SIZE; x++) {
        for (let z = 0; z < WORLD_SIZE; z++) {
          const nx = x * SCALE, nz = z * SCALE;
          const hVal = (noise(nx, nz) * 0.6) + (noise(nx * 0.5, nz * 0.5) * 0.4);
          const height = Math.floor((hVal * 0.5 + 0.5) * MAX_HEIGHT);
          for (let y = 0; y <= height; y++) {
            const type = y === height ? "grass" : (y > height - 3 ? "dirt" : "stone");
            setBlock(x,y,z,type);
          }
        }
      }
    }
    generateTerrain();

    /* =============================================================================================
       Chunk management with InstancedMesh (low draw calls)
    ============================================================================================= */
    const chunks = new Map(); // key "cx,cz" -> { group, meshes: {grass,dirt,stone}, count }
    function chunkKey(cx,cz){ return `${cx},${cz}`; }

    const matrixTemp = new THREE.Matrix4();

    function buildChunkInstanced(cx, cz) {
      const group = new THREE.Group();
      const startX = cx * CHUNK_SIZE;
      const startZ = cz * CHUNK_SIZE;

      const grass = [], dirt = [], stone = [];

      for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let lz = 0; lz < CHUNK_SIZE; lz++) {
          const wx = startX + lx;
          const wz = startZ + lz;
          for (let y = 0; y <= MAX_HEIGHT; y++) {
            const type = getBlock(wx,y,wz);
            if (!type) continue;
            const pos = new THREE.Vector3(wx + 0.5, y + 0.5, wz + 0.5);
            if (type === "grass") grass.push(pos);
            else if (type === "dirt") dirt.push(pos);
            else stone.push(pos);
          }
        }
      }

      function makeInstanced(arr, mat) {
        if (!arr.length) return null;
        const inst = new THREE.InstancedMesh(blockGeo, mat, arr.length);
        for (let i = 0; i < arr.length; i++) {
          matrixTemp.makeTranslation(arr[i].x, arr[i].y, arr[i].z);
          inst.setMatrixAt(i, matrixTemp);
        }
        inst.instanceMatrix.needsUpdate = true;
        inst.castShadow = false;
        inst.receiveShadow = false;
        group.add(inst);
        return inst;
      }

      const meshes = {
        grass: makeInstanced(grass, matGrass),
        dirt:  makeInstanced(dirt,  matDirt),
        stone: makeInstanced(stone, matStone),
      };
      const count = grass.length + dirt.length + stone.length;
      return { group, meshes, count };
    }

    function loadChunk(cx, cz) {
      const ck = chunkKey(cx, cz);
      if (chunks.has(ck)) return;
      const built = buildChunkInstanced(cx, cz);
      if (built.count > 0) {
        scene.add(built.group);
        chunks.set(ck, built);
      } else {
        chunks.set(ck, { group: null, meshes: {}, count: 0 });
      }
    }

    function unloadFarChunks(centerCx, centerCz) {
      for (const [ck, data] of chunks) {
        const [sx, sz] = ck.split(',').map(Number);
        const dx = Math.abs(sx - centerCx);
        const dz = Math.abs(sz - centerCz);
        if (dx > VIEW_RADIUS || dz > VIEW_RADIUS) {
          if (data.group) scene.remove(data.group);
          chunks.delete(ck);
        }
      }
    }

    let lastChunkUpdate = 0;
    const CHUNK_UPDATE_INTERVAL_MS = 120; // throttle chunk updates

    function updateVisibleChunks(px, pz, nowMs) {
      if (nowMs - lastChunkUpdate < CHUNK_UPDATE_INTERVAL_MS) return;
      lastChunkUpdate = nowMs;

      const cx = Math.floor(px / CHUNK_SIZE);
      const cz = Math.floor(pz / CHUNK_SIZE);
      const maxCx = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;
      const maxCz = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;

      for (let dx = -VIEW_RADIUS; dx <= VIEW_RADIUS; dx++) {
        for (let dz = -VIEW_RADIUS; dz <= VIEW_RADIUS; dz++) {
          const ncx = cx + dx, ncz = cz + dz;
          if (ncx < 0 || ncz < 0 || ncx > maxCx || ncz > maxCz) continue;
          loadChunk(ncx, ncz);
        }
      }
      unloadFarChunks(cx, cz);
    }

    function rebuildChunkAtBlock(x, y, z) {
      const cx = Math.floor(x / CHUNK_SIZE);
      const cz = Math.floor(z / CHUNK_SIZE);
      const ck = chunkKey(cx, cz);
      const cur = chunks.get(ck);
      if (!cur) return; // chunk not loaded now

      if (cur.group) scene.remove(cur.group);
      const rebuilt = buildChunkInstanced(cx, cz);
      if (rebuilt.count > 0) {
        scene.add(rebuilt.group);
        chunks.set(ck, rebuilt);
      } else {
        chunks.set(ck, { group: null, meshes: {}, count: 0 });
      }
    }

    /* =============================================================================================
       Player and collision handling
    ============================================================================================= */
    const capsuleRadius = 0.4;
    const capsuleMid = 1.0;
    const capsuleHeight = capsuleMid + 2 * capsuleRadius;

    const capsuleGeo = new THREE.CapsuleGeometry(capsuleRadius, capsuleMid, 8, 16);
    const capsuleMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
    const player = new THREE.Mesh(capsuleGeo, capsuleMat);
    player.position.set(WORLD_SIZE/2 + 0.5, MAX_HEIGHT + 8, WORLD_SIZE/2 + 0.5);
    player.castShadow = false;
    player.receiveShadow = false;
    scene.add(player);

    const playerVel = new THREE.Vector3(0, 0, 0);
    const GRAVITY = 22;
    const MOVE_SPEED = 6.0;
    const JUMP_SPEED = 9.6;
    let onGround = false;
    let pov = "third";
    let yaw = 0;
    let pitch = 0;

    function getFacingVectors() {
      const cosY = Math.cos(yaw), sinY = Math.sin(yaw);
      const forward = new THREE.Vector3(-sinY, 0, -cosY).normalize();
      const right   = new THREE.Vector3( cosY, 0, -sinY).normalize();
      return { forward, right };
    }

    function groundSnapAndDetect(dt) {
      let nextY = player.position.y + playerVel.y * dt;
      const footY = nextY - capsuleHeight / 2;

      const px = player.position.x;
      const pz = player.position.z;

      const minX = Math.floor(px - capsuleRadius + 0.001);
      const maxX = Math.floor(px + capsuleRadius - 0.001);
      const minZ = Math.floor(pz - capsuleRadius + 0.001);
      const maxZ = Math.floor(pz + capsuleRadius - 0.001);

      const probeY = Math.floor(footY - 0.05);
      let highestGround = -Infinity;
      for (let x = minX; x <= maxX; x++) {
        for (let z = minZ; z <= maxZ; z++) {
          if (getBlock(x, probeY, z)) {
            highestGround = Math.max(highestGround, probeY + 1);
          }
        }
      }

      if (highestGround !== -Infinity && playerVel.y <= 0) {
        const desiredPlayerY = highestGround + capsuleHeight / 2;
        if (nextY < desiredPlayerY) {
          player.position.y = desiredPlayerY;
          playerVel.y = 0;
          onGround = true;
          return;
        }
      }

      player.position.y = nextY;
      onGround = false;
    }

    function horizontalResolve(axis) {
      const radius = capsuleRadius;
      const halfH = capsuleHeight / 2;
      const centerY = player.position.y;

      const px = player.position.x;
      const pz = player.position.z;

      const minX = Math.floor(px - radius - 1);
      const maxX = Math.floor(px + radius + 1);
      const minY = Math.floor(centerY - halfH);
      const maxY = Math.floor(centerY + halfH);
      const minZ = Math.floor(pz - radius - 1);
      const maxZ = Math.floor(pz + radius + 1);

      for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
          for (let z = minZ; z <= maxZ; z++) {
            if (!getBlock(x,y,z)) continue;
            const bx = x + 0.5, by = y + 0.5, bz = z + 0.5;
            const dx = px - bx;
            const dz = pz - bz;
            const vertGap = Math.max(0, Math.abs(centerY - by) - 0.5);
            const horizDist = Math.hypot(dx, dz);

            if (vertGap < halfH && horizDist < radius + 0.5) {
              const overlap = (radius + 0.5) - horizDist;
              if (overlap > 0) {
                const nx = dx / (horizDist || 1e-6);
                const nz = dz / (horizDist || 1e-6);
                if (axis === 'x') player.position.x += nx * overlap;
                else              player.position.z += nz * overlap;
              }
            }
          }
        }
      }
    }

    /* =============================================================================================
       Joystick input and rotation-aligned movement
       - Up (finger moves up) -> forward relative to yaw
       - Down -> backward
       - Left/Right -> strafe relative to yaw
    ============================================================================================= */
    const joystick = document.getElementById("joystick");
    const stick = document.getElementById("stick");
    let joyInput = { x: 0, y: 0 };
    const JOY_RADIUS = 56;
    let joyCenter = null;

    function recalcJoyCenter() {
      const rect = joystick.getBoundingClientRect();
      joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
    }
    recalcJoyCenter();
    window.addEventListener('resize', recalcJoyCenter);

    function updateJoystick(e) {
      const t = e.touches[0];
      const dx = t.clientX - joyCenter.x;
      const dy = t.clientY - joyCenter.y;

      // Normalize to [-1, 1] and clamp
      const nx = clamp(dx / JOY_RADIUS, -1, 1);
      const ny = clamp(dy / JOY_RADIUS, -1, 1);

      // Movement mapping: screen up (ny<0) -> forward (+y)
      joyInput.x = nx;     // strafe left/right
      joyInput.y = -ny;    // forward/back

      // Visual stick follows finger
      stick.style.left = (41 + nx * JOY_RADIUS) + "px";
      stick.style.top  = (41 + ny * JOY_RADIUS) + "px";
    }
    joystick.addEventListener("touchstart", updateJoystick, { passive: true });
    joystick.addEventListener("touchmove",  updateJoystick, { passive: true });
    joystick.addEventListener("touchend", () => {
      joyInput.x = 0; joyInput.y = 0;
      stick.style.left = "41px"; stick.style.top = "41px";
    });

    /* =============================================================================================
       Touch drag rotation (exclude joystick touches)
    ============================================================================================= */
    let dragging = false, lastX = 0, lastY = 0;
    document.addEventListener("touchstart", e => {
      if (e.target.closest("#joystick")) return;
      dragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener("touchmove", e => {
      if (!dragging) return;
      const tx = e.touches[0].clientX;
      const ty = e.touches[0].clientY;
      const dx = tx - lastX;
      const dy = ty - lastY;
      yaw   -= dx * 0.005;
      pitch -= dy * 0.005;
      pitch = clamp(pitch, -Math.PI/3, Math.PI/3);
      lastX = tx; lastY = ty;
    }, { passive: true });

    document.addEventListener("touchend", () => { dragging = false; }, { passive: true });

    /* =============================================================================================
       Buttons: POV toggle, Jump, Place/Delete, Reseed
    ============================================================================================= */
    const povBtn    = document.getElementById("povBtn");
    const jumpBtn   = document.getElementById("jumpBtn");
    const placeBtn  = document.getElementById("placeBtn");
    const deleteBtn = document.getElementById("deleteBtn");
    const reseedBtn = document.getElementById("reseedBtn");

    povBtn.addEventListener("click", () => {
      pov = (pov === "third") ? "first" : "third";
      povBtn.textContent = `POV: ${pov === "third" ? "Third" : "First"}`;
    });

    jumpBtn.addEventListener("click", () => {
      if (onGround) { playerVel.y = JUMP_SPEED; onGround = false; }
    });

    const raycaster = new THREE.Raycaster();
    function collectVisibleInstanced() {
      const arr = [];
      for (const { meshes } of chunks.values()) {
        if (!meshes) continue;
        if (meshes.grass) arr.push(meshes.grass);
        if (meshes.dirt)  arr.push(meshes.dirt);
        if (meshes.stone) arr.push(meshes.stone);
      }
      return arr;
    }
    function getCenterRayHit() {
      const ndc = new THREE.Vector2(0, 0);
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(collectVisibleInstanced(), false);
      return hits.length ? hits[0] : null;
    }

    placeBtn.addEventListener("click", () => {
      const hit = getCenterRayHit();
      if (!hit) return;
      const normalWorld = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
      const p = hit.point.clone().addScaledVector(normalWorld, 0.5);
      const x = Math.floor(p.x), y = Math.floor(p.y), z = Math.floor(p.z);
      if (x < 0 || z < 0 || x >= WORLD_SIZE || z >= WORLD_SIZE || y < 0 || y > MAX_HEIGHT + 20) return;
      setBlock(x,y,z,"grass");
      rebuildChunkAtBlock(x,y,z);
    });

    deleteBtn.addEventListener("click", () => {
      const hit = getCenterRayHit();
      if (!hit) return;
      const x = Math.floor(hit.point.x);
      const y = Math.floor(hit.point.y);
      const z = Math.floor(hit.point.z);
      clearBlock(x,y,z);
      rebuildChunkAtBlock(x,y,z);
    });

    reseedBtn.addEventListener("click", () => {
      SEED = Math.floor(Math.random() * 1e9);
      noise = makeNoise2D(SEED);
      generateTerrain();
      // Rebuild all currently loaded chunks
      const loaded = Array.from(chunks.keys()).map(k => k.split(',').map(Number));
      for (const [cx, cz] of loaded) {
        const ck = chunkKey(cx, cz);
        const cur = chunks.get(ck);
        if (cur && cur.group) scene.remove(cur.group);
        chunks.delete(ck);
        loadChunk(cx, cz);
      }
    });

    /* =============================================================================================
       Camera (first/third person) with smoothing
    ============================================================================================= */
    const camPos = new THREE.Vector3();
    const camTarget = new THREE.Vector3();
    let CAM_LERP = 0.18;

    function updateCamera() {
      const target = player.position.clone();
      if (pov === "first") {
        const eye = target.clone().add(new THREE.Vector3(0, capsuleHeight * 0.35, 0));
        const look = new THREE.Vector3(Math.sin(-yaw), Math.sin(pitch), Math.cos(-yaw)).normalize();
        camPos.copy(eye);
        camTarget.copy(eye).add(look);
      } else {
        const d = 8.4;
        const offX = Math.sin(yaw) * Math.cos(pitch) * d;
        const offZ = Math.cos(yaw) * Math.cos(pitch) * d;
        const offY = Math.sin(pitch) * d * 0.6;
        const desired = target.clone().add(new THREE.Vector3(-offX, 1.6 + offY, -offZ));
        camPos.lerp(desired, CAM_LERP);
        camTarget.lerp(target.clone().add(new THREE.Vector3(0, 1.2, 0)), CAM_LERP);
      }
      camera.position.copy(camPos);
      camera.lookAt(camTarget);
    }

    /* =============================================================================================
       Fog control
    ============================================================================================= */
    function updateFog(distance) {
      if (distance > 0) {
        scene.fog = new THREE.Fog(scene.background, distance * 0.35, distance);
      } else {
        scene.fog = null;
      }
    }
    updateFog(700);

    /* =============================================================================================
       Minimap (player tracker), smaller size
    ============================================================================================= */
    const minimapCanvas = document.getElementById("minimapCanvas");
    const mmCtx = minimapCanvas.getContext("2d");

    function drawMinimap() {
      const show = document.getElementById("minimapToggle").checked;
      document.getElementById("minimap").style.display = show ? "grid" : "none";
      if (!show) return;

      mmCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
      mmCtx.fillStyle = "#0d1420";
      mmCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

      const scale = minimapCanvas.width / (VIEW_RADIUS * 2 * CHUNK_SIZE + CHUNK_SIZE);
      const cx = Math.floor(player.position.x / CHUNK_SIZE);
      const cz = Math.floor(player.position.z / CHUNK_SIZE);

      mmCtx.strokeStyle = "rgba(255,255,255,0.25)";
      mmCtx.strokeRect(0,0,minimapCanvas.width,minimapCanvas.height);

      // Draw chunk tiles around player
      mmCtx.fillStyle = "rgba(90,160,255,0.20)";
      for (let dx = -VIEW_RADIUS; dx <= VIEW_RADIUS; dx++) {
        for (let dz = -VIEW_RADIUS; dz <= VIEW_RADIUS; dz++) {
          const x = (dx + VIEW_RADIUS) * CHUNK_SIZE * scale;
          const z = (dz + VIEW_RADIUS) * CHUNK_SIZE * scale;
          mmCtx.fillRect(x, z, CHUNK_SIZE * scale, CHUNK_SIZE * scale);
        }
      }

      // Player marker (smaller radius due to smaller tracker)
      mmCtx.fillStyle = "#ff4444";
      const px = (player.position.x - (cx - VIEW_RADIUS) * CHUNK_SIZE) * scale;
      const pz = (player.position.z - (cz - VIEW_RADIUS) * CHUNK_SIZE) * scale;
      mmCtx.beginPath();
      mmCtx.arc(px, pz, 2.5, 0, Math.PI*2);
      mmCtx.fill();

      // Direction arrow (aligned to yaw)
      mmCtx.strokeStyle = "#ff4444";
      mmCtx.beginPath();
      mmCtx.moveTo(px, pz);
      mmCtx.lineTo(px + Math.sin(-yaw) * 10, pz + Math.cos(-yaw) * 10);
      mmCtx.stroke();
    }

    /* =============================================================================================
       Settings bindings (incl. close/open panel button)
    ============================================================================================= */
    const viewRadiusSlider = document.getElementById("viewRadiusSlider");
    const viewRadiusLabel  = document.getElementById("viewRadiusLabel");
    const chunkSizeSlider  = document.getElementById("chunkSizeSlider");
    const chunkSizeLabel   = document.getElementById("chunkSizeLabel");
    const heightSlider     = document.getElementById("heightSlider");
    const heightLabel      = document.getElementById("heightLabel");
    const fogSlider        = document.getElementById("fogSlider");
    const fogLabel         = document.getElementById("fogLabel");
    const aaToggle         = document.getElementById("aaToggle");
    const shadowToggle     = document.getElementById("shadowToggle");
    const closePanelBtn    = document.getElementById("closePanelBtn");
    const openPanelBtn     = document.getElementById("openPanelBtn");

    closePanelBtn.addEventListener("click", () => {
      document.getElementById("panel").style.display = "none";
      openPanelBtn.style.display = "inline-block";
      openPanelBtn.style.position = "absolute";
      openPanelBtn.style.left = "12px";
      openPanelBtn.style.bottom = "200px";
    });

    openPanelBtn.addEventListener("click", () => {
      document.getElementById("panel").style.display = "block";
      openPanelBtn.style.display = "none";
    });

    viewRadiusSlider.addEventListener("input", () => {
      VIEW_RADIUS = parseInt(viewRadiusSlider.value, 10);
      viewRadiusLabel.textContent = VIEW_RADIUS.toString();
      lastChunkUpdate = 0;
    });

    chunkSizeSlider.addEventListener("input", () => {
      const newSize = parseInt(chunkSizeSlider.value, 10);
      chunkSizeLabel.textContent = newSize.toString();
      if (newSize !== CHUNK_SIZE) {
        CHUNK_SIZE = newSize;
        // Clear loaded chunks; they'll reload around player on next update
        for (const [ck, data] of chunks) {
          if (data.group) scene.remove(data.group);
          chunks.delete(ck);
        }
        lastChunkUpdate = 0;
      }
    });

    heightSlider.addEventListener("input", () => {
      const newH = parseInt(heightSlider.value, 10);
      heightLabel.textContent = newH.toString();
      MAX_HEIGHT = newH;
      generateTerrain();
      // Rebuild loaded chunks
      const loaded = Array.from(chunks.keys()).map(k => k.split(',').map(Number));
      for (const [cx, cz] of loaded) {
        const ck = chunkKey(cx, cz);
        const cur = chunks.get(ck);
        if (cur && cur.group) scene.remove(cur.group);
        chunks.delete(ck);
        loadChunk(cx, cz);
      }
    });

    fogSlider.addEventListener("input", () => {
      const dist = parseInt(fogSlider.value, 10);
      fogLabel.textContent = dist.toString();
      updateFog(dist);
    });

    aaToggle.addEventListener("change", () => {
      ANTIALIAS = aaToggle.checked;
      // Recreate renderer
      renderer.dispose();
      const old = renderer.domElement;
      old.parentNode.removeChild(old);
      const newRenderer = new THREE.WebGLRenderer({ antialias: ANTIALIAS, powerPreference: "high-performance" });
      newRenderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(newRenderer.domElement);
      renderer = newRenderer;
      bindPointerLockMouseMove();
    });

    shadowToggle.addEventListener("change", () => {
      const enable = shadowToggle.checked;
      dir.intensity = enable ? 0.45 : 0.0;
      renderer.shadowMap.enabled = enable;
      player.castShadow = enable;
      player.receiveShadow = false;
      for (const data of chunks.values()) {
        if (!data.meshes) continue;
        for (const mesh of [data.meshes.grass, data.meshes.dirt, data.meshes.stone]) {
          if (mesh) {
            mesh.castShadow = false; // keep off for performance
            mesh.receiveShadow = enable;
          }
        }
      }
    });

    /* =============================================================================================
       Desktop controls and pointer lock (optional)
    ============================================================================================= */
    const keys = new Set();
    window.addEventListener('keydown', e => {
      keys.add(e.code);
      if (e.code === "Space") jumpBtn.click();
    });
    window.addEventListener('keyup', e => keys.delete(e.code));

    let pointerLockEnabled = false;
    function enablePointerLock() {
      const c = renderer.domElement;
      if (c.requestPointerLock) c.requestPointerLock();
    }
    document.addEventListener('pointerlockchange', () => {
      pointerLockEnabled = (document.pointerLockElement === renderer.domElement);
    });

    // Double-click to toggle pointer lock
    let lastClick = 0;
    renderer.domElement.addEventListener('click', () => {
      const now = performance.now();
      if (now - lastClick < 300) enablePointerLock();
      lastClick = now;
    });

    function bindPointerLockMouseMove() {
      renderer.domElement.addEventListener('mousemove', e => {
        if (!pointerLockEnabled) return;
        const dx = e.movementX || 0;
        const dy = e.movementY || 0;
        yaw   -= dx * 0.0025;
        pitch -= dy * 0.0025;
        pitch = clamp(pitch, -Math.PI/3, Math.PI/3);
      });
    }
    bindPointerLockMouseMove();

    // Map WASD to joystick vector to maintain single movement pipeline
    function desktopControlsToJoystick() {
      let x = 0, y = 0; // x=strife, y=forward/back
      if (keys.has("KeyA")) x -= 1;
      if (keys.has("KeyD")) x += 1;
      if (keys.has("KeyW")) y += 1;
      if (keys.has("KeyS")) y -= 1;
      const len = Math.hypot(x, y); if (len > 0) { x /= len; y /= len; }
      joyInput.x = x; joyInput.y = y;
      // Visual stick mirrors keyboard input
      stick.style.left = (41 + x * JOY_RADIUS) + "px";
      stick.style.top  = (41 - y * JOY_RADIUS) + "px"; // invert visual Y to match screen
      requestAnimationFrame(desktopControlsToJoystick);
    }
    desktopControlsToJoystick();

    /* =============================================================================================
       Main loop: physics, chunk updates, movement, camera, render
    ============================================================================================= */
    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.033);
      lastTime = now;

      // Keep nearby chunks loaded (throttled)
      updateVisibleChunks(player.position.x, player.position.z, now);

      // Gravity and vertical motion
      playerVel.y -= GRAVITY * dt;
      groundSnapAndDetect(dt);

      // Movement relative to rotation (forward/back/strafe aligned with yaw)
      const { forward, right } = getFacingVectors();
      const moveDir = new THREE.Vector3()
        .addScaledVector(forward, joyInput.y)
        .addScaledVector(right,   joyInput.x);
      if (moveDir.lengthSq() > 0) moveDir.normalize();

      const vx = moveDir.x * MOVE_SPEED;
      const vz = moveDir.z * MOVE_SPEED;

      // Horizontal separation: resolve X then Z axis to avoid jitter
      player.position.x += vx * dt;
      horizontalResolve('x');

      player.position.z += vz * dt;
      horizontalResolve('z');

      // Floor safety and bounds
      player.position.x = clamp(player.position.x, capsuleRadius, WORLD_SIZE - capsuleRadius);
      player.position.z = clamp(player.position.z, capsuleRadius, WORLD_SIZE - capsuleRadius);
      if (player.position.y < capsuleHeight / 2) {
        player.position.y = capsuleHeight / 2;
        playerVel.y = 0;
        onGround = true;
      }

      // Camera and UI
      updateCamera();
      drawMinimap();
      renderer.render(scene, camera);
    }
    animate();

    /* =============================================================================================
       Resize handler
    ============================================================================================= */
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      recalcJoyCenter();
    });

    /* =============================================================================================
       Initial chunk preload around player for fast first frame
    ============================================================================================= */
    (function preloadInitial() {
      const cx = Math.floor(player.position.x / CHUNK_SIZE);
      const cz = Math.floor(player.position.z / CHUNK_SIZE);
      const maxCx = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;
      const maxCz = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;
      for (let dx = -VIEW_RADIUS; dx <= VIEW_RADIUS; dx++) {
        for (let dz = -VIEW_RADIUS; dz <= VIEW_RADIUS; dz++) {
          const ncx = cx + dx, ncz = cz + dz;
          if (ncx < 0 || ncz < 0 || ncx > maxCx || ncz > maxCz) continue;
          loadChunk(ncx, ncz);
        }
      }
    })();
  </script>
</body>
</html>
