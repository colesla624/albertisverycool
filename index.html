<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Third Person Platformer</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#0b1026; }
  .stick {
    position:fixed; bottom:16px; width:120px; height:120px; border-radius:50%;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.18);
    touch-action:none;
  }
  #stickLeft { left:16px; }
  #stickRight { right:16px; }
  .knob {
    position:absolute; left:50%; top:50%; width:54px; height:54px; border-radius:50%;
    transform:translate(-50%,-50%); background:rgba(97,225,255,0.35);
  }
  #btnJump {
    position:fixed; right:18px; bottom:150px; width:76px; height:76px; border-radius:50%;
    background:#202859; color:#e9ecff; font-size:16px;
  }
</style>
</head>
<body>
<div id="stickLeft" class="stick"><div class="knob"></div></div>
<div id="stickRight" class="stick"><div class="knob"></div></div>
<button id="btnJump">Jump</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1026);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 500);

  scene.add(new THREE.HemisphereLight(0x8a5cff,0x0b1026,0.9));
  const dir = new THREE.DirectionalLight(0xffffff,1.0);
  dir.position.set(40,50,25);
  scene.add(dir);

  // Ground
  const ground = new THREE.Mesh(new THREE.BoxGeometry(40,2,40), new THREE.MeshStandardMaterial({color:0x1b2250}));
  ground.position.y=-1;
  scene.add(ground);

  // Platforms
  const platforms=[];
  function addPlatform(x,y,z){
    const p=new THREE.Mesh(new THREE.BoxGeometry(8,1,8), new THREE.MeshStandardMaterial({color:0x61e1ff}));
    p.position.set(x,y,z);
    scene.add(p);
    platforms.push(p);
  }
  addPlatform(0,2,-10);
  addPlatform(12,4,-15);
  addPlatform(-8,3,-20);

  // Player
  const player={pos:new THREE.Vector3(0,2,5), vel:new THREE.Vector3(), yaw:0, grounded:false, speed:6, jumpVel:15}; // jump 2x stronger
  const playerMesh=new THREE.Mesh(new THREE.CapsuleGeometry(0.5,1,8,16),new THREE.MeshStandardMaterial({color:0xff7aa2}));
  scene.add(playerMesh);

  // Camera follow
  const camOffset=new THREE.Vector3(0,2.5,6.5);
  function updateCamera(){
    const cos=Math.cos(player.yaw),sin=Math.sin(player.yaw);
    const offset=new THREE.Vector3(camOffset.x*cos+camOffset.z*sin,camOffset.y,-camOffset.x*sin+camOffset.z*cos);
    camera.position.copy(player.pos).add(offset);
    camera.lookAt(player.pos);
  }

  // Joysticks
  let moveStick={x:0,y:0}, lookStick={x:0,y:0};
  function setupStick(el,onMove){
    const knob=el.querySelector(".knob"); let active=false;
    el.addEventListener("touchstart",()=>{active=true;},{passive:true});
    el.addEventListener("touchmove",e=>{
      if(!active)return; const rect=el.getBoundingClientRect(); const t=e.touches[0];
      const dx=t.clientX-(rect.left+rect.width/2); const dy=t.clientY-(rect.top+rect.height/2);
      const r=50,mag=Math.hypot(dx,dy),cl=mag>r?r/mag:1; const nx=dx*cl,ny=dy*cl;
      knob.style.transform=`translate(${nx}px,${ny}px) translate(-50%,-50%)`; onMove(nx/r,ny/r); e.preventDefault();
    },{passive:false});
    function reset(){active=false;knob.style.transform="translate(-50%,-50%)";onMove(0,0);}
    el.addEventListener("touchend",reset,{passive:true});
    el.addEventListener("touchcancel",reset,{passive:true});
  }
  setupStick(document.getElementById("stickLeft"),(x,y)=>{moveStick.x=x;moveStick.y=y;});
  setupStick(document.getElementById("stickRight"),(x,y)=>{lookStick.x=x;lookStick.y=y;});

  // Jump button
  document.getElementById("btnJump").addEventListener("click",()=>{if(player.grounded){player.vel.y=player.jumpVel;player.grounded=false;}});

  // Collision check
  function getAABB(mesh){
    mesh.geometry.computeBoundingBox();
    const bb=mesh.geometry.boundingBox.clone();
    bb.min.add(mesh.position);
    bb.max.add(mesh.position);
    return bb;
  }
  function checkCollisions(){
    player.grounded=false;
    const colliders=platforms.concat([ground]);
    for(const m of colliders){
      const bb=getAABB(m);
      if(player.pos.x>=bb.min.x-0.5 && player.pos.x<=bb.max.x+0.5 &&
         player.pos.z>=bb.min.z-0.5 && player.pos.z<=bb.max.z+0.5){
        if(player.pos.y<=bb.max.y+0.1 && player.pos.y>=bb.max.y-1){
          player.pos.y=bb.max.y;
          player.vel.y=0;
          player.grounded=true;
        }
      }
    }
  }

  // Loop
  function loop(){
    requestAnimationFrame(loop);
    const dt=0.016;
    let fwd=moveStick.y; let str=moveStick.x;
    const len=Math.hypot(fwd,str); if(len>1){fwd/=len;str/=len;}
    const cos=Math.cos(player.yaw),sin=Math.sin(player.yaw);
    player.pos.x+=(str*cos+fwd*sin)*player.speed*dt;
    player.pos.z+=(str*-sin+fwd*cos)*player.speed*dt;
    player.vel.y-=9.8*dt; player.pos.y+=player.vel.y*dt;
    checkCollisions();
    playerMesh.position.copy(player.pos);
    player.yaw-=lookStick.x*2.5*dt;
    updateCamera();
    renderer.render(scene,camera);
  }
  loop();
})();
</script>
</body>
</html>
