<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lucid Platformer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #0e0f1a; }
    canvas { display: block; }
    #hud {
      position: absolute; top: 10px; left: 10px;
      color: #e7e7ff; font-family: system-ui, sans-serif; font-size: 16px;
      text-shadow: 0 0 6px rgba(170,170,255,0.7);
    }
    #tip {
      position: absolute; top: 10px; right: 10px; color: #a9a9ff; font-size: 12px; opacity: 0.8;
      font-family: system-ui, sans-serif;
    }
    #controls {
      position: absolute; bottom: 20px; left: 20px; right: 20px;
      display: flex; justify-content: space-between; align-items: center;
      pointer-events: auto;
    }
    .pad {
      width: 120px; height: 120px; border-radius: 60px;
      background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.25), rgba(255,255,255,0.08));
      position: relative; touch-action: none;
    }
    .stick {
      position: absolute; width: 60px; height: 60px; border-radius: 30px;
      background: rgba(255,255,255,0.5); top: 30px; left: 30px;
      transform: translate(0,0);
    }
    .btn {
      width: 120px; height: 120px; border-radius: 60px;
      background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.25), rgba(255,255,255,0.08));
      color: #fff; font-size: 20px; display: grid; place-items: center; user-select: none;
    }
  </style>
</head>
<body>
  <div id="hud">Time: 0.0s · Orbs: 0/5</div>
  <div id="tip">Desktop: WASD + Space + Mouse. Mobile: left pad to move, swipe to look, Jump button.</div>
  <div id="controls">
    <div class="pad" id="movePad"><div class="stick" id="moveStick"></div></div>
    <div class="btn" id="jumpBtn">Jump</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    // Scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x10122a, 0.035);
    scene.background = new THREE.Color(0x10122a);

    // Camera (first-person)
    const camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.05, 1000);
    camera.position.set(0, 1.7, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    document.body.appendChild(renderer.domElement);

    // Dreamy lighting
    const hemi = new THREE.HemisphereLight(0x99aaff, 0x404070, 0.8);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xb0b8ff, 0.8);
    dir.position.set(10, 20, -10);
    scene.add(dir);

    // Materials
    const platformMat = new THREE.MeshStandardMaterial({ color: 0x6b6fde, roughness: 0.8, metalness: 0.05 });
    const accentMat = new THREE.MeshStandardMaterial({ color: 0xffb3da, emissive: 0x301030, emissiveIntensity: 0.3 });
    const orbMat = new THREE.MeshStandardMaterial({ color: 0x9cf0ff, emissive: 0x78d4ff, emissiveIntensity: 0.8 });

    // Platforms (floating islands)
    const platforms = [];
    function addPlatform(x, y, z, w=6, h=0.6, d=6) {
      const geo = new THREE.BoxGeometry(w, h, d);
      const mesh = new THREE.Mesh(geo, platformMat);
      mesh.position.set(x, y, z);
      mesh.receiveShadow = true;
      scene.add(mesh);
      platforms.push({ mesh, w, h, d });
      return mesh;
    }

    // Level layout
    addPlatform(0, 0, 0, 10, 0.6, 10);        // start island
    addPlatform(12, 2, -6, 6, 0.6, 6);
    addPlatform(24, 4, -12, 6, 0.6, 6);
    addPlatform(36, 6, -6, 9, 0.6, 6);
    addPlatform(48, 8, 0, 12, 0.6, 8);
    addPlatform(60, 10, -10, 8, 0.6, 8);
    addPlatform(72, 12, -20, 10, 0.6, 10);    // goal island

    // Decorative dream pillars
    for (let i=0; i<20; i++) {
      const g = new THREE.CylinderGeometry(0.4, 0.9, 6 + Math.random()*8, 24);
      const m = new THREE.Mesh(g, accentMat);
      m.position.set((Math.random()-0.5)*80, -4, (Math.random()-0.5)*80);
      scene.add(m);
    }

    // Orbs to collect (lucidity anchors)
    const orbs = [];
    function addOrb(x, y, z) {
      const g = new THREE.SphereGeometry(0.35, 24, 24);
      const orb = new THREE.Mesh(g, orbMat);
      orb.position.set(x, y, z);
      scene.add(orb);
      orbs.push(orb);
    }
    addOrb(0, 2, 0);
    addOrb(12, 4, -6);
    addOrb(24, 6, -12);
    addOrb(48, 10, 0);
    addOrb(72, 14, -20);

    // Player physics
    const player = {
      pos: new THREE.Vector3(0, 2, 2),
      vel: new THREE.Vector3(0, 0, 0),
      yaw: 0, pitch: 0,
      radius: 0.4,
      onGround: false
    };

    // Spawn directly on first platform
    const startPlat = platforms[0];
    const startTopY = startPlat.mesh.position.y + startPlat.h/2;
    player.pos.set(startPlat.mesh.position.x, startTopY + player.radius, startPlat.mesh.position.z);

    // Input state
    const keys = {};
    document.addEventListener('keydown', e => { keys[e.code] = true; });
    document.addEventListener('keyup',   e => { keys[e.code] = false; });

    // Mouse look (desktop)
    let pointerLocked = false;
    renderer.domElement.addEventListener('click', () => {
      if (!pointerLocked) renderer.domElement.requestPointerLock();
    });
    document.addEventListener('pointerlockchange', () => {
      pointerLocked = (document.pointerLockElement === renderer.domElement);
    });
    document.addEventListener('mousemove', e => {
      if (!pointerLocked) return;
      const sensitivity = 0.0022;
      player.yaw   -= e.movementX * sensitivity;
      player.pitch -= e.movementY * sensitivity;
      player.pitch = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, player.pitch));
    });

    // Touch: move pad (left) and swipe-to-look
    const movePad = document.getElementById('movePad');
    const moveStick = document.getElementById('moveStick');
    const jumpBtn = document.getElementById('jumpBtn');
    let moveActive = false, moveBase = {x:0,y:0}, moveVec = {x:0,y:0};
    function setStick(dx, dy) { moveStick.style.transform = `translate(${dx}px, ${dy}px)`; }
    function clamp(n, max) { return Math.max(-max, Math.min(max, n)); }

    movePad.addEventListener('touchstart', e => {
      const t = e.changedTouches[0]; moveActive = true;
      const rect = movePad.getBoundingClientRect();
      moveBase.x = rect.left + rect.width/2; moveBase.y = rect.top + rect.height/2;
    }, {passive:false});
    movePad.addEventListener('touchmove', e => {
      e.preventDefault();
      const t = e.changedTouches[0];
      const dx = clamp(t.clientX - moveBase.x, 40);
      const dy = clamp(t.clientY - moveBase.y, 40);
      setStick(dx, dy);
      moveVec.x = dx / 40; moveVec.y = dy / 40;
    }, {passive:false});
    movePad.addEventListener('touchend', () => { moveActive = false; moveVec.x = 0; moveVec.y = 0; setStick(0,0); });

    jumpBtn.addEventListener('touchstart', () => tryJump());

    // Swipe to look anywhere else on screen
    let looking = false, lastTouch = null;
    document.addEventListener('touchstart', e => {
      if (e.target === movePad || e.target === moveStick || e.target === jumpBtn) return;
      looking = true; lastTouch = e.changedTouches[0];
    }, {passive:true});
    document.addEventListener('touchmove', e => {
      if (!looking) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - lastTouch.clientX;
      const dy = t.clientY - lastTouch.clientY;
      lastTouch = t;
      const sensitivity = 0.006;
      player.yaw   -= dx * sensitivity;
      player.pitch -= dy * sensitivity;
      player.pitch = Math.max(-Math.PI/2+0.05, Math.min(Math.PI/2-0.05, player.pitch));
    }, {passive:true});
    document.addEventListener('touchend', () => { looking = false; });

    // Movement helpers
    function getMoveInput() {
      let mx = 0, mz = 0;
      if (keys['KeyW']) mz -= 1;
      if (keys['KeyS']) mz += 1;
      if (keys['KeyA']) mx -= 1;
      if (keys['KeyD']) mx += 1;
      mx += moveVec.x;
      mz += moveVec.y;
      const len = Math.hypot(mx, mz);
      return len > 1 ? {x: mx/len, z: mz/len} : {x: mx, z: mz};
    }
    function tryJump() {
      if (player.onGround) {
        player.vel.y = 5.4;
        player.onGround = false;
      }
    }
    document.addEventListener('keydown', e => { if (e.code === 'Space') tryJump(); });

    // Physics params
    const GRAVITY = -6.5;
    const MOVE_SPEED = 6.5;
    const AIR_CONTROL = 0.35;

    // Precise AABB top-surface collision
    function collidePlatforms(nextPos, vel) {
      player.onGround = false;

      for (const p of platforms) {
        const m = p.mesh;
        const half = { x: p.w/2, y: p.h/2, z: p.d/2 };
        const min = new THREE.Vector3(m.position.x - half.x, m.position.y - half.y, m.position.z - half.z);
        const max = new THREE.Vector3(m.position.x + half.x, m.position.y + half.y, m.position.z + half.z);

        // Horizontal overlap considering player radius
        const withinX = nextPos.x > (min.x - player.radius) && nextPos.x < (max.x + player.radius);
        const withinZ = nextPos.z > (min.z - player.radius) && nextPos.z < (max.z + player.radius);

        if (withinX && withinZ) {
          const top = max.y;
          const descending = vel.y <= 0;
          const wasAboveTop = (player.pos.y - player.radius) >= (top - 0.05);
          const crossesTop = (nextPos.y - player.radius) <= top;

          if (descending && wasAboveTop && crossesTop) {
            nextPos.y = top + player.radius; // stand on top
            vel.y = 0;
            player.onGround = true;
          }
        }
      }
    }

    // Collect orbs
    let collected = 0;
    function checkOrbs() {
      for (let i = orbs.length - 1; i >= 0; i--) {
        const o = orbs[i];
        const dist = player.pos.distanceTo(o.position);
        if (dist < 1.2) {
          scene.remove(o);
          orbs.splice(i, 1);
          collected++;
        } else {
          o.position.y += Math.sin(performance.now()*0.002 + i) * 0.003;
        }
      }
    }

    // HUD
    const hud = document.getElementById('hud');
    let timeSurvived = 0;
    function updateHUD() {
      hud.textContent = `Time: ${timeSurvived.toFixed(1)}s · Orbs: ${collected}/5`;
    }

    // Atmosphere shift
    function updateAtmosphere(t) {
      const hue = (Math.sin(t*0.0003)*0.5+0.5)*0.2 + 0.6;
      dir.color.setHSL(hue, 0.45, 0.75);
      hemi.color.setHSL(hue, 0.5, 0.7);
    }

    // Main loop
    let last = performance.now();
    function loop(now) {
      requestAnimationFrame(loop);
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      timeSurvived += dt;

      // Look direction
      const forward = new THREE.Vector3(Math.sin(player.yaw), 0, Math.cos(player.yaw));
      const right   = new THREE.Vector3(Math.cos(player.yaw), 0, -Math.sin(player.yaw));

      // Movement input -> desired velocity
      const input = getMoveInput();
      const wish = new THREE.Vector3(
        right.x * input.x + forward.x * input.z,
        0,
        right.z * input.x + forward.z * input.z
      );

      const accel = player.onGround ? MOVE_SPEED : MOVE_SPEED * AIR_CONTROL;
      player.vel.x = THREE.MathUtils.damp(player.vel.x, wish.x * accel, 8, dt);
      player.vel.z = THREE.MathUtils.damp(player.vel.z, wish.z * accel, 8, dt);

      // Gravity
      player.vel.y += GRAVITY * dt;

      // Integrate
      const nextPos = player.pos.clone().addScaledVector(player.vel, dt);

      // Collisions with platforms
      collidePlatforms(nextPos, player.vel);

      // Death if fall off
      if (nextPos.y < -30) {
        const topY = startPlat.mesh.position.y + startPlat.h/2;
        nextPos.set(startPlat.mesh.position.x, topY + player.radius, startPlat.mesh.position.z);
        player.vel.set(0,0,0);
      }

      // Commit position
      player.pos.copy(nextPos);

      // Camera placement (first-person)
      camera.position.copy(player.pos);
      camera.position.y += 1.3; // eye height above physics point
      camera.rotation.set(player.pitch, player.yaw, 0);

      // Orbs + HUD + atmosphere
      checkOrbs();
      updateHUD();
      updateAtmosphere(now);

      renderer.render(scene, camera);
    }
    loop(performance.now());

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
