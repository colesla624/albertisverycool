<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>First Person Platformer â€” Dual Joysticks</title>
<style>
  html, body { margin:0; height:100%; overflow:hidden; background:#0b1026; font-family:system-ui,sans-serif; color:#e9ecff; }
  #hud { position:fixed; top:10px; left:50%; transform:translateX(-50%); font-size:14px; text-shadow:0 2px 8px rgba(0,0,0,0.5); }
  .stick {
    position:fixed; bottom:16px; width:120px; height:120px; border-radius:50%;
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.18);
    touch-action:none; backdrop-filter:blur(6px);
  }
  #stickLeft { left:16px; }
  #stickRight { right:16px; }
  .knob {
    position:absolute; left:50%; top:50%; width:54px; height:54px; border-radius:50%;
    transform:translate(-50%,-50%); background:rgba(97,225,255,0.35); border:1px solid rgba(97,225,255,0.6);
  }
  #btnJump {
    position:fixed; right:18px; bottom:150px; width:76px; height:76px; border-radius:50%;
    background:linear-gradient(180deg,#2d3a7a,#202859); border:1px solid #4450a8; color:#e9ecff; font-size:16px;
    box-shadow:0 8px 20px rgba(0,0,0,0.4); touch-action:none;
  }
</style>
</head>
<body>
<div id="hud">Crystals: <span id="score">0</span></div>
<div id="stickLeft" class="stick"><div class="knob"></div></div>
<div id="stickRight" class="stick"><div class="knob"></div></div>
<button id="btnJump">Jump</button>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
(() => {
  // Scene setup
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x0b1026, 35, 160);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);

  // Lighting
  const hemi = new THREE.HemisphereLight(0x8a5cff, 0x0b1026, 0.8);
  scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff, 0.9);
  dir.position.set(30, 40, 20);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024,1024);
  scene.add(dir);

  // Materials
  const matGround = new THREE.MeshStandardMaterial({ color:0x1b2250, roughness:0.9 });
  const matPlat = new THREE.MeshStandardMaterial({ color:0x61e1ff, emissive:0x103a46, emissiveIntensity:0.35, roughness:0.6 });
  const matCrystal = new THREE.MeshStandardMaterial({ color:0xffd46b, emissive:0x704f10, emissiveIntensity:0.6 });

  // Ground
  const ground = new THREE.Mesh(new THREE.BoxGeometry(40, 1, 40), matGround);
  ground.position.y = -0.5;
  ground.receiveShadow = true;
  scene.add(ground);

  // Platforms (reachable)
  const platforms = [];
  function addPlatform(x,y,z,w=6,h=1,d=6){
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), matPlat);
    m.position.set(x,y,z);
    m.castShadow = true; m.receiveShadow = true;
    scene.add(m); platforms.push(m);
  }
  addPlatform(6, 2, 0);
  addPlatform(12, 3, 0);
  addPlatform(18, 4, 0);
  addPlatform(24, 5, 0);

  // Crystals
  const crystals = [];
  function addCrystal(x,y,z){
    const c = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.6, 8), matCrystal);
    c.position.set(x, y + 1.1, z);
    c.castShadow = true;
    scene.add(c); crystals.push(c);
  }
  addCrystal(12, 3, 0);
  addCrystal(24, 5, 0);

  // Player (first-person camera attached)
  const player = {
    pos: new THREE.Vector3(0, 1.7, 2),
    vel: new THREE.Vector3(0, 0, 0),
    yaw: 0, pitch: 0,
    radius: 0.6,
    grounded: false,
    speed: 6.0,
    jumpVel: 5.5
  };
  camera.position.copy(player.pos);

  // HUD
  let score = 0; const scoreEl = document.getElementById("score");

  // Joysticks
  let moveStick = { x:0, y:0 }, lookStick = { x:0, y:0 };
  function setupStick(el, onMove){
    const knob = el.querySelector(".knob");
    let active = false;
    el.addEventListener("touchstart", () => { active = true; }, {passive:true});
    el.addEventListener("touchmove", (e) => {
      if(!active) return;
      const rect = el.getBoundingClientRect();
      const t = e.touches[0];
      const dx = t.clientX - (rect.left + rect.width/2);
      const dy = t.clientY - (rect.top + rect.height/2);
      const r = 50, mag = Math.hypot(dx, dy), cl = mag > r ? r/mag : 1;
      const nx = dx * cl, ny = dy * cl;
      knob.style.transform = `translate(${nx}px, ${ny}px) translate(-50%,-50%)`;
      onMove(nx/r, ny/r);
      e.preventDefault();
    }, {passive:false});
    function reset(){ active = false; knob.style.transform = "translate(-50%,-50%)"; onMove(0,0); }
    el.addEventListener("touchend", reset, {passive:true});
    el.addEventListener("touchcancel", reset, {passive:true});
  }
  setupStick(document.getElementById("stickLeft"), (x,y) => { moveStick.x = x; moveStick.y = y; });
  setupStick(document.getElementById("stickRight"), (x,y) => { lookStick.x = x; lookStick.y = y; });

  // Jump button
  const btnJump = document.getElementById("btnJump");
  function attemptJump(){
    if(player.grounded){
      player.vel.y = player.jumpVel;
      player.grounded = false;
    }
  }
  btnJump.addEventListener("click", attemptJump);
  btnJump.addEventListener("touchstart", (e) => { e.preventDefault(); attemptJump(); }, {passive:false});

  // Helpers
  function getAABB(mesh){
    mesh.geometry.computeBoundingBox();
    const bb = mesh.geometry.boundingBox.clone();
    bb.min.add(mesh.position); bb.max.add(mesh.position);
    return bb;
  }

  // Collision: sphere vs AABB (inflate box by radius)
  function resolveCollisions(pos, vel, radius){
    let grounded = false;
    const objs = platforms.concat([ground]);
    for(const m of objs){
      const bb = getAABB(m);
      const minX = bb.min.x - radius, maxX = bb.max.x + radius;
      const minY = bb.min.y - radius, maxY = bb.max.y + radius;
      const minZ = bb.min.z - radius, maxZ = bb.max.z + radius;

      if(pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY && pos.z >= minZ && pos.z <= maxZ){
        const penX = Math.min(maxX - pos.x, pos.x - minX);
        const penY = Math.min(maxY - pos.y, pos.y - minY);
        const penZ = Math.min(maxZ - pos.z, pos.z - minZ);
        const minPen = Math.min(penX, penY, penZ);

        if(minPen === penY){
          if(pos.y > (bb.max.y + bb.min.y)/2){
            pos.y = maxY; vel.y = Math.max(0, vel.y); grounded = true;
          } else {
            pos.y = minY; vel.y = Math.min(0, vel.y);
          }
        } else if(minPen === penX){
          if(pos.x > (bb.max.x + bb.min.x)/2){ pos.x = maxX; } else { pos.x = minX; }
          vel.x = 0;
        } else {
          if(pos.z > (bb.max.z + bb.min.z)/2){ pos.z = maxZ; } else { pos.z = minZ; }
          vel.z = 0;
        }
      }
    }
    return grounded;
  }

  // Resize
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Main loop
  function loop(now){
    const dt = Math.min(0.033, (now - (loop.last || now)) / 1000);
    loop.last = now;

    // Movement (left joystick, flipped forward/back)
    let forward = -moveStick.y;
    let strafe = moveStick.x;
    const len = Math.hypot(forward, strafe);
    if(len > 1){ forward /= len; strafe /= len; }
    const speed = player.speed;
    const cos = Math.cos(player.yaw), sin = Math.sin(player.yaw);
    player.vel.x = (strafe * cos + forward * sin) * speed;
    player.vel.z = (strafe * -sin + forward * cos) * speed;

    // Integrate horizontal
    player.pos.x += player.vel.x * dt;
    player.pos.z += player.vel.z * dt;

    // Gravity
    player.vel.y -= 9.8 * dt;
    player.pos.y += player.vel.y * dt;

    // Collisions
    player.grounded = resolveCollisions(player.pos, player.vel, player.radius);

    // Fall reset
    if(player.pos.y < -10){
      player.pos.set(0, 1.7, 2);
      player.vel.set(0, 0, 0);
      player.yaw = 0; player.pitch = 0;
    }

    // Look (right joystick)
    const sensitivityYaw = 2.5;
    const sensitivityPitch = 2.0;
    player.yaw -= lookStick.x * sensitivityYaw * dt;
    player.pitch -= lookStick.y * sensitivityPitch * dt;
    const maxPitch = Math.PI/2 - 0.05, minPitch = -Math.PI/2 + 0.05;
    player.pitch = Math.max(minPitch, Math.min(maxPitch, player.pitch));

    // Camera (first-person)
    camera.position.copy(player.pos);
    camera.rotation.set(player.pitch, player.yaw, 0);

    // Collect crystals
    for(let i=crystals.length-1;i>=0;i--){
      if(camera.position.distanceTo(crystals[i].position) < 1.5){
        scene.remove(crystals[i]); crystals.splice(i,1);
        score++; scoreEl.textContent = score;
      }
    }

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
