<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Minecraft-like — Full build (~1000+ lines), alternative joystick movement, instanced chunks, closable settings, smaller tracker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

  <style>
    /* =================================================================================================
       Base theme and global layout
       -------------------------------------------------------------------------------------------------
       - Dark theme for better contrast against bright skybox and UI
       - Box sizing set to border-box for consistent layout behavior
       - Prevent page scroll; the canvas is the primary viewport
       - Use system fonts for good performance on mobile and desktop
       ================================================================================================= */
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0b1b2b;
      color: #e6f3ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    canvas { display: block; }

    /* =================================================================================================
       Interactive buttons
       -------------------------------------------------------------------------------------------------
       - Minimal glass-style buttons
       - Hover effect for desktop
       - Ensure pointer usability on mobile with proper hit areas
       ================================================================================================= */
    .btn {
      padding: 10px 14px;
      background: rgba(30,30,30,0.65);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.35);
      border-radius: 8px;
      font-size: 14px;
      backdrop-filter: blur(4px);
      user-select: none;
      touch-action: manipulation;
      cursor: pointer;
    }
    .btn:hover { filter: brightness(1.08); }

    #povBtn {
      position: absolute;
      top: 12px;
      left: 12px;
      z-index: 10;
    }

    #uiRight {
      position: absolute;
      right: 14px;
      bottom: 160px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
    }

    #jumpBtn {
      position: absolute;
      right: 14px;
      bottom: 20px;
      z-index: 10;
    }

    /* =================================================================================================
       Crosshair (center of screen)
       -------------------------------------------------------------------------------------------------
       - Simple plus crosshair to align raycasts and block placement interaction
       - Non-interactive pointer events for performance and behavior
       ================================================================================================= */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px; height: 20px;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: 5;
      opacity: 0.9;
    }
    #crosshair::before, #crosshair::after {
      content: "";
      position: absolute;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 0 2px rgba(0,0,0,0.4);
    }
    #crosshair::before { width: 2px; height: 20px; left: 9px; top: 0; }
    #crosshair::after  { width: 20px; height: 2px; left: 0; top: 9px; }

    /* =================================================================================================
       Alternative movement joystick (ring + puck)
       -------------------------------------------------------------------------------------------------
       - Big outer ring with a smaller puck
       - Optional 8-way wedge snapping (via settings toggle)
       - Built with pure DOM, no canvas
       - Movement maps to player-relative forward/back/strafe using yaw
       ================================================================================================= */
    #moveJoystick {
      position: absolute;
      bottom: 24px;
      left: 24px;
      width: 180px;
      height: 180px;
      border-radius: 50%;
      z-index: 10;
      touch-action: none;
      background:
        radial-gradient(closest-side, rgba(255,255,255,0.06), rgba(255,255,255,0.03) 40%, transparent 41%),
        conic-gradient(from 0deg, rgba(255,255,255,0.06) 0 45deg, rgba(255,255,255,0.10) 45deg 90deg, rgba(255,255,255,0.06) 90deg 135deg, rgba(255,255,255,0.10) 135deg 180deg, rgba(255,255,255,0.06) 180deg 225deg, rgba(255,255,255,0.10) 225deg 270deg, rgba(255,255,255,0.06) 270deg 315deg, rgba(255,255,255,0.10) 315deg 360deg);
      border: 2px solid rgba(255,255,255,0.25);
      box-shadow: inset 0 0 18px rgba(0,0,0,0.5);
    }
    #movePuck {
      position: absolute;
      width: 64px; height: 64px;
      left: 58px; top: 58px; /* centered initially (180-64)/2 = 58 */
      border-radius: 50%;
      background: linear-gradient(180deg, rgba(180,200,255,0.65), rgba(90,120,200,0.65));
      border: 2px solid rgba(255,255,255,0.35);
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      touch-action: none;
    }

    /* =================================================================================================
       Right-side camera joystick (smaller, optional)
       -------------------------------------------------------------------------------------------------
       - Small ring to control yaw/pitch with smooth deltas
       - Puck returns to center on release
       ================================================================================================= */
    #lookJoystick {
      position: absolute;
      bottom: 24px;
      right: 24px;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      z-index: 10;
      touch-action: none;
      background:
        radial-gradient(closest-side, rgba(255,255,255,0.06), rgba(255,255,255,0.03) 40%, transparent 41%),
        conic-gradient(from 0deg, rgba(255,255,255,0.08) 0 180deg, rgba(255,255,255,0.05) 180deg 360deg);
      border: 2px solid rgba(255,255,255,0.25);
      box-shadow: inset 0 0 16px rgba(0,0,0,0.5);
    }
    #lookPuck {
      position: absolute;
      width: 52px; height: 52px;
      left: 44px; top: 44px; /* centered initially (140-52)/2 = 44 */
      border-radius: 50%;
      background: linear-gradient(180deg, rgba(255,180,180,0.65), rgba(200,90,90,0.65));
      border: 2px solid rgba(255,255,255,0.35);
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      touch-action: none;
    }

    /* =================================================================================================
       Closable settings panel
       -------------------------------------------------------------------------------------------------
       - Per request: button to close panel
       - No top-right stats HUD; panel focuses on toggles
       ================================================================================================= */
    #panel {
      position: absolute;
      left: 12px;
      bottom: 200px;
      z-index: 10;
      width: 300px;
      max-width: calc(100vw - 24px);
      background: rgba(10, 18, 28, 0.75);
      color: #e6f3ff;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 10px;
      padding: 12px;
      backdrop-filter: blur(6px);
    }
    #panel h3 {
      margin: 0 0 10px 0;
      font-size: 15px;
      color: #a8d0ff;
    }
    #panel .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin: 8px 0;
    }
    #panel input[type="range"] { width: 165px; }
    #panel .small { font-size: 12px; opacity: 0.9; }
    #panel .mono  { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    #panelButtons {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    /* =================================================================================================
       Minimap (player tracker) — smaller per request
       -------------------------------------------------------------------------------------------------
       - Pixelated scaling for retro vibe
       - Player marker reflects yaw direction
       ================================================================================================= */
    #minimap {
      position: absolute;
      right: 14px;
      top: 70px;
      width: 120px; /* smaller tracker */
      height: 120px; /* smaller tracker */
      z-index: 10;
      background: rgba(0, 0, 0, 0.35);
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      backdrop-filter: blur(4px);
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    #minimap canvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      border-radius: 8px;
    }

    /* =================================================================================================
       Helper tip
       -------------------------------------------------------------------------------------------------
       - Small footer help text to explain interactions
       ================================================================================================= */
    .tip {
      position: absolute;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.45);
      color: #e6f3ff;
      border: 1px solid rgba(255,255,255,0.25);
      border-radius: 8px;
      padding: 6px 10px;
      font-size: 12px;
      z-index: 10;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <!-- =================================================================================================
       UI elements
       -------------------------------------------------------------------------------------------------
       - Core controls and panels
       - Movement and look joysticks
       ================================================================================================= -->
  <div id="crosshair"></div>

  <button id="povBtn" class="btn">POV: Third</button>

  <div id="uiRight">
    <button id="placeBtn" class="btn">Place</button>
    <button id="deleteBtn" class="btn">Delete</button>
    <button id="reseedBtn" class="btn">Reseed</button>
  </div>

  <button id="jumpBtn" class="btn">Jump</button>

  <!-- Alternative movement joystick -->
  <div id="moveJoystick">
    <div id="movePuck"></div>
  </div>

  <!-- Right-side look joystick (camera control) -->
  <div id="lookJoystick">
    <div id="lookPuck"></div>
  </div>

  <div id="panel">
    <h3>Settings</h3>

    <div class="row">
      <span class="small">View radius (chunks)</span>
      <input type="range" id="viewRadiusSlider" min="2" max="10" step="1" value="5"/>
      <span id="viewRadiusLabel" class="mono small">5</span>
    </div>

    <div class="row">
      <span class="small">Chunk size (blocks)</span>
      <input type="range" id="chunkSizeSlider" min="8" max="24" step="1" value="12"/>
      <span id="chunkSizeLabel" class="mono small">12</span>
    </div>

    <div class="row">
      <span class="small">Max height</span>
      <input type="range" id="heightSlider" min="12" max="40" step="1" value="22"/>
      <span id="heightLabel" class="mono small">22</span>
    </div>

    <div class="row">
      <span class="small">Fog distance</span>
      <input type="range" id="fogSlider" min="200" max="1200" step="50" value="700"/>
      <span id="fogLabel" class="mono small">700</span>
    </div>

    <div class="row">
      <span class="small">Antialias</span>
      <input type="checkbox" id="aaToggle" checked />
    </div>

    <div class="row">
      <span class="small">Shadows</span>
      <input type="checkbox" id="shadowToggle" />
    </div>

    <div class="row">
      <span class="small">Show minimap</span>
      <input type="checkbox" id="minimapToggle" checked />
    </div>

    <div class="row">
      <span class="small">8-way snap movement</span>
      <input type="checkbox" id="snap8Toggle" />
    </div>

    <div id="panelButtons">
      <button id="closePanelBtn" class="btn">Close settings</button>
      <button id="openPanelBtn" class="btn" style="display:none">Open settings</button>
    </div>
  </div>

  <div id="minimap"><canvas id="minimapCanvas" width="120" height="120"></canvas></div>

  <div class="tip">Double-click for mouse look. Left ring joystick moves. Right ring joystick looks. Place/Delete to modify blocks.</div>

  <!-- =================================================================================================
       Scripts
       -------------------------------------------------------------------------------------------------
       - Three.js and the full game logic
       ================================================================================================= -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    /* =================================================================================================
       Utilities: seeded noise and math helpers
       -------------------------------------------------------------------------------------------------
       - Mulberry32 PRNG for deterministic randomness
       - Simple Perlin-like 2D noise for terrain height
       - Clamp and vector helpers
       ================================================================================================= */
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function makeNoise2D(seed = 1337) {
      const rand = mulberry32(seed);
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) perm[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(rand() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 256; i++) perm[256 + i] = perm[i];
      function fade(t){ return t*t*t*(t*(t*6-15)+10); }
      function lerp(a,b,t){ return a + t*(b-a); }
      function grad(hash,x,y){
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
      }
      return function(x,y){
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x), v = fade(y);
        const aa = perm[X + perm[Y]];
        const ab = perm[X + perm[Y + 1]];
        const ba = perm[X + 1 + perm[Y]];
        const bb = perm[X + 1 + perm[Y + 1]];
        return lerp(lerp(grad(aa,x,y),grad(ba,x-1,y),u), lerp(grad(ab,x,y-1),grad(bb,x-1,y-1),u), v);
      };
    }

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function length2(x, y){ return Math.sqrt(x*x + y*y); }
    function normalize2(x, y){
      const L = Math.sqrt(x*x + y*y) || 1;
      return { x: x / L, y: y / L };
    }
    function snap8(x, y){
      const ang = Math.atan2(y, x); // -pi..pi
      const sector = Math.round(ang / (Math.PI / 4)); // 8 sectors
      const snappedAng = sector * (Math.PI / 4);
      return { x: Math.cos(snappedAng), y: Math.sin(snappedAng) };
    }

    /* =================================================================================================
       Scene, camera, renderer
       -------------------------------------------------------------------------------------------------
       - Perspective camera
       - High-performance WebGLRenderer
       - Hemisphere light + optional shadowed directional light
       ================================================================================================= */
    let ANTIALIAS = true;
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1600);
    let renderer = new THREE.WebGLRenderer({ antialias: ANTIALIAS, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x889988, 0.7);
    const dir = new THREE.DirectionalLight(0xffffff, 0.0); // disabled by default; toggled via settings
    dir.position.set(20, 30, 10);
    scene.add(hemi); scene.add(dir);

    /* =================================================================================================
       World parameters and materials
       -------------------------------------------------------------------------------------------------
       - Tunable chunk size and view radius
       - Simple Lambert materials per block type
       ================================================================================================= */
    let WORLD_SIZE = 320;   // square world size in blocks
    let MAX_HEIGHT = 22;    // max terrain height
    let CHUNK_SIZE = 12;    // blocks per chunk side
    let VIEW_RADIUS = 5;    // chunk radius around player
    let SEED = 1337;        // initial seed

    const blockGeo = new THREE.BoxGeometry(1, 1, 1);
    const matGrass = new THREE.MeshLambertMaterial({ color: 0x3a9d23 });
    const matDirt  = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
    const matStone = new THREE.MeshLambertMaterial({ color: 0x7f7f7f });

    /* =================================================================================================
       World storage and terrain generation (sparse map)
       -------------------------------------------------------------------------------------------------
       - Keyed by "x,y,z" for simplicity in this prototype
       - Noise-based terrain with grass/dirt/stone stratification
       ================================================================================================= */
    let noise = makeNoise2D(SEED);
    let SCALE = 0.06;

    const world = new Map(); // key "x,y,z" -> type
    function K(x,y,z){ return `${x},${y},${z}`; }
    function getBlock(x,y,z){ return world.get(K(x,y,z)); }
    function setBlock(x,y,z,type){ world.set(K(x,y,z), type); }
    function clearBlock(x,y,z){ world.delete(K(x,y,z)); }

    function generateTerrain() {
      world.clear();
      for (let x = 0; x < WORLD_SIZE; x++) {
        for (let z = 0; z < WORLD_SIZE; z++) {
          const nx = x * SCALE, nz = z * SCALE;
          const hVal = (noise(nx, nz) * 0.6) + (noise(nx * 0.5, nz * 0.5) * 0.4);
          const height = Math.floor((hVal * 0.5 + 0.5) * MAX_HEIGHT);
          for (let y = 0; y <= height; y++) {
            const type = y === height ? "grass" : (y > height - 3 ? "dirt" : "stone");
            setBlock(x,y,z,type);
          }
        }
      }
    }
    generateTerrain();

    /* =================================================================================================
       Chunk management with InstancedMesh (low draw calls)
       -------------------------------------------------------------------------------------------------
       - Each chunk creates up to three InstancedMesh (grass/dirt/stone)
       - Simple visibility by radius; unload far chunks
       ================================================================================================= */
    const chunks = new Map(); // key "cx,cz" -> { group, meshes: {grass,dirt,stone}, count }
    function chunkKey(cx,cz){ return `${cx},${cz}`; }

    const matrixTemp = new THREE.Matrix4();

    function buildChunkInstanced(cx, cz) {
      const group = new THREE.Group();
      const startX = cx * CHUNK_SIZE;
      const startZ = cz * CHUNK_SIZE;

      const grass = [], dirt = [], stone = [];

      for (let lx = 0; lx < CHUNK_SIZE; lx++) {
        for (let lz = 0; lz < CHUNK_SIZE; lz++) {
          const wx = startX + lx;
          const wz = startZ + lz;
          for (let y = 0; y <= MAX_HEIGHT; y++) {
            const type = getBlock(wx,y,wz);
            if (!type) continue;
            const pos = new THREE.Vector3(wx + 0.5, y + 0.5, wz + 0.5);
            if (type === "grass") grass.push(pos);
            else if (type === "dirt") dirt.push(pos);
            else stone.push(pos);
          }
        }
      }

      function makeInstanced(arr, mat) {
        if (!arr.length) return null;
        const inst = new THREE.InstancedMesh(blockGeo, mat, arr.length);
        for (let i = 0; i < arr.length; i++) {
          matrixTemp.makeTranslation(arr[i].x, arr[i].y, arr[i].z);
          inst.setMatrixAt(i, matrixTemp);
        }
        inst.instanceMatrix.needsUpdate = true;
        inst.castShadow = false;
        inst.receiveShadow = false;
        group.add(inst);
        return inst;
      }

      const meshes = {
        grass: makeInstanced(grass, matGrass),
        dirt:  makeInstanced(dirt,  matDirt),
        stone: makeInstanced(stone, matStone),
      };
      const count = grass.length + dirt.length + stone.length;
      return { group, meshes, count };
    }

    function loadChunk(cx, cz) {
      const ck = chunkKey(cx, cz);
      if (chunks.has(ck)) return;
      const built = buildChunkInstanced(cx, cz);
      if (built.count > 0) {
        scene.add(built.group);
        chunks.set(ck, built);
      } else {
        chunks.set(ck, { group: null, meshes: {}, count: 0 });
      }
    }

    function unloadFarChunks(centerCx, centerCz) {
      for (const [ck, data] of chunks) {
        const [sx, sz] = ck.split(',').map(Number);
        const dx = Math.abs(sx - centerCx);
        const dz = Math.abs(sz - centerCz);
        if (dx > VIEW_RADIUS || dz > VIEW_RADIUS) {
          if (data.group) scene.remove(data.group);
          chunks.delete(ck);
        }
      }
    }

    let lastChunkUpdate = 0;
    const CHUNK_UPDATE_INTERVAL_MS = 120; // throttle chunk updates

    function updateVisibleChunks(px, pz, nowMs) {
      if (nowMs - lastChunkUpdate < CHUNK_UPDATE_INTERVAL_MS) return;
      lastChunkUpdate = nowMs;

      const cx = Math.floor(px / CHUNK_SIZE);
      const cz = Math.floor(pz / CHUNK_SIZE);
      const maxCx = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;
      const maxCz = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;

      for (let dx = -VIEW_RADIUS; dx <= VIEW_RADIUS; dx++) {
        for (let dz = -VIEW_RADIUS; dz <= VIEW_RADIUS; dz++) {
          const ncx = cx + dx, ncz = cz + dz;
          if (ncx < 0 || ncz < 0 || ncx > maxCx || ncz > maxCz) continue;
          loadChunk(ncx, ncz);
        }
      }
      unloadFarChunks(cx, cz);
    }

    function rebuildChunkAtBlock(x, y, z) {
      const cx = Math.floor(x / CHUNK_SIZE);
      const cz = Math.floor(z / CHUNK_SIZE);
      const ck = chunkKey(cx, cz);
      const cur = chunks.get(ck);
      if (!cur) return; // chunk not loaded now

      if (cur.group) scene.remove(cur.group);
      const rebuilt = buildChunkInstanced(cx, cz);
      if (rebuilt.count > 0) {
        scene.add(rebuilt.group);
        chunks.set(ck, rebuilt);
      } else {
        chunks.set(ck, { group: null, meshes: {}, count: 0 });
      }
    }

    /* =================================================================================================
       Player and collision handling
       -------------------------------------------------------------------------------------------------
       - Capsule player proxy for collision bounds
       - Gravity and simple ground snap detection
       - Axis-separated horizontal collision resolution
       ================================================================================================= */
    const capsuleRadius = 0.4;
    const capsuleMid = 1.0;
    const capsuleHeight = capsuleMid + 2 * capsuleRadius;

    const capsuleGeo = new THREE.CapsuleGeometry(capsuleRadius, capsuleMid, 8, 16);
    const capsuleMat = new THREE.MeshLambertMaterial({ color: 0xff4444 });
    const player = new THREE.Mesh(capsuleGeo, capsuleMat);
    player.position.set(WORLD_SIZE/2 + 0.5, MAX_HEIGHT + 8, WORLD_SIZE/2 + 0.5);
    player.castShadow = false;
    player.receiveShadow = false;
    scene.add(player);

    const playerVel = new THREE.Vector3(0, 0, 0);
    const GRAVITY = 22;
    const MOVE_SPEED = 6.0;
    const JUMP_SPEED = 9.6;
    let onGround = false;
    let pov = "third";
    let yaw = 0;
    let pitch = 0;

    function getFacingVectors() {
      const cosY = Math.cos(yaw), sinY = Math.sin(yaw);
      const forward = new THREE.Vector3(-sinY, 0, -cosY).normalize();
      const right   = new THREE.Vector3( cosY, 0, -sinY).normalize();
      return { forward, right };
    }

    function groundSnapAndDetect(dt) {
      let nextY = player.position.y + playerVel.y * dt;
      const footY = nextY - capsuleHeight / 2;

      const px = player.position.x;
      const pz = player.position.z;

      const minX = Math.floor(px - capsuleRadius + 0.001);
      const maxX = Math.floor(px + capsuleRadius - 0.001);
      const minZ = Math.floor(pz - capsuleRadius + 0.001);
      const maxZ = Math.floor(pz + capsuleRadius - 0.001);

      const probeY = Math.floor(footY - 0.05);
      let highestGround = -Infinity;
      for (let x = minX; x <= maxX; x++) {
        for (let z = minZ; z <= maxZ; z++) {
          if (getBlock(x, probeY, z)) {
            highestGround = Math.max(highestGround, probeY + 1);
          }
        }
      }

      if (highestGround !== -Infinity && playerVel.y <= 0) {
        const desiredPlayerY = highestGround + capsuleHeight / 2;
        if (nextY < desiredPlayerY) {
          player.position.y = desiredPlayerY;
          playerVel.y = 0;
          onGround = true;
          return;
        }
      }

      player.position.y = nextY;
      onGround = false;
    }

    function horizontalResolve(axis) {
      const radius = capsuleRadius;
      const halfH = capsuleHeight / 2;
      const centerY = player.position.y;

      const px = player.position.x;
      const pz = player.position.z;

      const minX = Math.floor(px - radius - 1);
      const maxX = Math.floor(px + radius + 1);
      const minY = Math.floor(centerY - halfH);
      const maxY = Math.floor(centerY + halfH);
      const minZ = Math.floor(pz - radius - 1);
      const maxZ = Math.floor(pz + radius + 1);

      for (let x = minX; x <= maxX; x++) {
        for (let y = minY; y <= maxY; y++) {
          for (let z = minZ; z <= maxZ; z++) {
            if (!getBlock(x,y,z)) continue;
            const bx = x + 0.5, by = y + 0.5, bz = z + 0.5;
            const dx = px - bx;
            const dz = pz - bz;
            const vertGap = Math.max(0, Math.abs(centerY - by) - 0.5);
            const horizDist = Math.hypot(dx, dz);

            if (vertGap < halfH && horizDist < radius + 0.5) {
              const overlap = (radius + 0.5) - horizDist;
              if (overlap > 0) {
                const nx = dx / (horizDist || 1e-6);
                const nz = dz / (horizDist || 1e-6);
                if (axis === 'x') player.position.x += nx * overlap;
                else              player.position.z += nz * overlap;
              }
            }
          }
        }
      }
    }

    /* =================================================================================================
       Alternative joysticks: movement ring and look ring
       -------------------------------------------------------------------------------------------------
       - Movement input vector (moveInput) drives player translation
       - Look input vector (lookInput) drives yaw/pitch deltas with smoothing
       - Re-centering on touchend for both pucks
       ================================================================================================= */
    const moveJoystick = document.getElementById("moveJoystick");
    const movePuck = document.getElementById("movePuck");
    const lookJoystick = document.getElementById("lookJoystick");
    const lookPuck = document.getElementById("lookPuck");

    let moveInput = { x: 0, y: 0 }; // movement vector, normalized
    let lookInput = { x: 0, y: 0 }; // camera look deltas, -1..1

    // Centers and radius for both joysticks
    let moveCenter = { x: 0, y: 0 }, lookCenter = { x: 0, y: 0 };
    const moveRadiusPx = 76; // effective travel inside 180px ring
    const lookRadiusPx = 58; // effective travel inside 140px ring

    function recalcCenters(){
      const mRect = moveJoystick.getBoundingClientRect();
      moveCenter.x = mRect.left + mRect.width/2;
      moveCenter.y = mRect.top + mRect.height/2;
      const lRect = lookJoystick.getBoundingClientRect();
      lookCenter.x = lRect.left + lRect.width/2;
      lookCenter.y = lRect.top + lRect.height/2;
    }
    recalcCenters();
    window.addEventListener('resize', recalcCenters);

    function setPuck(el, cx, cy, dx, dy, maxR){
      const len = Math.min(length2(dx, dy), maxR);
      const ang = Math.atan2(dy, dx);
      const px = cx + Math.cos(ang) * len;
      const py = cy + Math.sin(ang) * len;

      const rect = el.parentElement.getBoundingClientRect();
      el.style.left = (px - rect.left - el.offsetWidth/2) + "px";
      el.style.top  = (py - rect.top  - el.offsetHeight/2) + "px";
    }

    const snap8Toggle = document.getElementById("snap8Toggle");

    // Movement joystick handlers
    function onMoveStart(e){
      const t = e.touches[0];
      const dx = t.clientX - moveCenter.x;
      const dy = t.clientY - moveCenter.y;
      const nx = clamp(dx / moveRadiusPx, -1, 1);
      const ny = clamp(dy / moveRadiusPx, -1, 1);

      if (snap8Toggle.checked){
        const s = snap8(nx, ny);
        moveInput.x = s.x;
        moveInput.y = -s.y; // screen up -> forward
        setPuck(movePuck, moveCenter.x, moveCenter.y, s.x * moveRadiusPx, s.y * moveRadiusPx, moveRadiusPx);
      } else {
        moveInput.x = nx;
        moveInput.y = -ny; // invert Y so up = forward
        setPuck(movePuck, moveCenter.x, moveCenter.y, dx, dy, moveRadiusPx);
      }
    }
    function onMoveMove(e){
      const t = e.touches[0];
      const dx = t.clientX - moveCenter.x;
      const dy = t.clientY - moveCenter.y;
      const nx = clamp(dx / moveRadiusPx, -1, 1);
      const ny = clamp(dy / moveRadiusPx, -1, 1);

      if (snap8Toggle.checked){
        const s = snap8(nx, ny);
        moveInput.x = s.x;
        moveInput.y = -s.y;
        setPuck(movePuck, moveCenter.x, moveCenter.y, s.x * moveRadiusPx, s.y * moveRadiusPx, moveRadiusPx);
      } else {
        moveInput.x = nx;
        moveInput.y = -ny;
        setPuck(movePuck, moveCenter.x, moveCenter.y, dx, dy, moveRadiusPx);
      }
    }
    function onMoveEnd(){
      moveInput.x = 0; moveInput.y = 0;
      movePuck.style.left = "58px";
      movePuck.style.top  = "58px";
    }
    moveJoystick.addEventListener("touchstart", onMoveStart, { passive: true });
    moveJoystick.addEventListener("touchmove",  onMoveMove,  { passive: true });
    moveJoystick.addEventListener("touchend",   onMoveEnd,   { passive: true });

    // Look joystick handlers (affects yaw/pitch smoothly)
    function onLookStart(e){
      const t = e.touches[0];
      const dx = t.clientX - lookCenter.x;
      const dy = t.clientY - lookCenter.y;
      const nx = clamp(dx / lookRadiusPx, -1, 1);
      const ny = clamp(dy / lookRadiusPx, -1, 1);
      lookInput.x = nx;
      lookInput.y = ny;
      setPuck(lookPuck, lookCenter.x, lookCenter.y, dx, dy, lookRadiusPx);
    }
    function onLookMove(e){
      const t = e.touches[0];
      const dx = t.clientX - lookCenter.x;
      const dy = t.clientY - lookCenter.y;
      const nx = clamp(dx / lookRadiusPx, -1, 1);
      const ny = clamp(dy / lookRadiusPx, -1, 1);
      lookInput.x = nx;
      lookInput.y = ny;
      setPuck(lookPuck, lookCenter.x, lookCenter.y, dx, dy, lookRadiusPx);
    }
    function onLookEnd(){
      lookInput.x = 0; lookInput.y = 0;
      lookPuck.style.left = "44px";
      lookPuck.style.top  = "44px";
    }
    lookJoystick.addEventListener("touchstart", onLookStart, { passive: true });
    lookJoystick.addEventListener("touchmove",  onLookMove,  { passive: true });
    lookJoystick.addEventListener("touchend",   onLookEnd,   { passive: true });

    /* =================================================================================================
       Touch drag rotation on empty areas (exclude both joysticks)
       -------------------------------------------------------------------------------------------------
       - Allows camera rotation even without look joystick
       ================================================================================================= */
    let dragging = false, lastX = 0, lastY = 0;
    document.addEventListener("touchstart", e => {
      if (e.target.closest("#moveJoystick") || e.target.closest("#lookJoystick")) return;
      dragging = true;
      lastX = e.touches[0].clientX;
      lastY = e.touches[0].clientY;
    }, { passive: true });

    document.addEventListener("touchmove", e => {
      if (!dragging) return;
      const tx = e.touches[0].clientX;
      const ty = e.touches[0].clientY;
      const dx = tx - lastX;
      const dy = ty - lastY;
      yaw   -= dx * 0.005;
      pitch -= dy * 0.005;
      pitch = clamp(pitch, -Math.PI/3, Math.PI/3);
      lastX = tx; lastY = ty;
    }, { passive: true });

    document.addEventListener("touchend", () => { dragging = false; }, { passive: true });

    /* =================================================================================================
       Buttons: POV toggle, Jump, Place/Delete, Reseed
       -------------------------------------------------------------------------------------------------
       - Simple handlers to change POV mode and modify the world using raycasting
       ================================================================================================= */
    const povBtn    = document.getElementById("povBtn");
    const jumpBtn   = document.getElementById("jumpBtn");
    const placeBtn  = document.getElementById("placeBtn");
    const deleteBtn = document.getElementById("deleteBtn");
    const reseedBtn = document.getElementById("reseedBtn");

    povBtn.addEventListener("click", () => {
      pov = (pov === "third") ? "first" : "third";
      povBtn.textContent = `POV: ${pov === "third" ? "Third" : "First"}`;
    });

    jumpBtn.addEventListener("click", () => {
      if (onGround) { playerVel.y = JUMP_SPEED; onGround = false; }
    });

    const raycaster = new THREE.Raycaster();
    function collectVisibleInstanced() {
      const arr = [];
      for (const { meshes } of chunks.values()) {
        if (!meshes) continue;
        if (meshes.grass) arr.push(meshes.grass);
        if (meshes.dirt)  arr.push(meshes.dirt);
        if (meshes.stone) arr.push(meshes.stone);
      }
      return arr;
    }
    function getCenterRayHit() {
      const ndc = new THREE.Vector2(0, 0);
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(collectVisibleInstanced(), false);
      return hits.length ? hits[0] : null;
    }

    placeBtn.addEventListener("click", () => {
      const hit = getCenterRayHit();
      if (!hit) return;
      const normalWorld = hit.face.normal.clone().transformDirection(hit.object.matrixWorld);
      const p = hit.point.clone().addScaledVector(normalWorld, 0.5);
      const x = Math.floor(p.x), y = Math.floor(p.y), z = Math.floor(p.z);
      if (x < 0 || z < 0 || x >= WORLD_SIZE || z >= WORLD_SIZE || y < 0 || y > MAX_HEIGHT + 20) return;
      setBlock(x,y,z,"grass");
      rebuildChunkAtBlock(x,y,z);
    });

    deleteBtn.addEventListener("click", () => {
      const hit = getCenterRayHit();
      if (!hit) return;
      const x = Math.floor(hit.point.x);
      const y = Math.floor(hit.point.y);
      const z = Math.floor(hit.point.z);
      clearBlock(x,y,z);
      rebuildChunkAtBlock(x,y,z);
    });

    reseedBtn.addEventListener("click", () => {
      SEED = Math.floor(Math.random() * 1e9);
      noise = makeNoise2D(SEED);
      generateTerrain();
      // Rebuild all currently loaded chunks
      const loaded = Array.from(chunks.keys()).map(k => k.split(',').map(Number));
      for (const [cx, cz] of loaded) {
        const ck = chunkKey(cx, cz);
        const cur = chunks.get(ck);
        if (cur && cur.group) scene.remove(cur.group);
        chunks.delete(ck);
        loadChunk(cx, cz);
      }
    });

    /* =================================================================================================
       Camera (first/third person) with smoothing
       -------------------------------------------------------------------------------------------------
       - Look joystick deltas applied each frame
       - Third person with offset and smoothing lerp
       ================================================================================================= */
    const camPos = new THREE.Vector3();
    const camTarget = new THREE.Vector3();
    let CAM_LERP = 0.18;

    /* dtGlobal is updated in animate() and used here; we declare it above animate */
    let dtGlobal = 0;

    function updateCamera() {
      // Apply look joystick deltas to yaw/pitch for smooth camera
      const lookYawSpeed = 1.6;   // radians per second at full deflection
      const lookPitchSpeed = 1.2; // radians per second at full deflection
      yaw   += lookInput.x * lookYawSpeed * dtGlobal;
      pitch -= lookInput.y * lookPitchSpeed * dtGlobal;
      pitch = clamp(pitch, -Math.PI/3, Math.PI/3);

      const target = player.position.clone();
      if (pov === "first") {
        const eye = target.clone().add(new THREE.Vector3(0, capsuleHeight * 0.35, 0));
        const look = new THREE.Vector3(Math.sin(-yaw), Math.sin(pitch), Math.cos(-yaw)).normalize();
        camPos.copy(eye);
        camTarget.copy(eye).add(look);
      } else {
        const d = 8.4;
        const offX = Math.sin(yaw) * Math.cos(pitch) * d;
        const offZ = Math.cos(yaw) * Math.cos(pitch) * d;
        const offY = Math.sin(pitch) * d * 0.6;
        const desired = target.clone().add(new THREE.Vector3(-offX, 1.6 + offY, -offZ));
        camPos.lerp(desired, CAM_LERP);
        camTarget.lerp(target.clone().add(new THREE.Vector3(0, 1.2, 0)), CAM_LERP);
      }
      camera.position.copy(camPos);
      camera.lookAt(camTarget);
    }

    /* =================================================================================================
       Fog control
       -------------------------------------------------------------------------------------------------
       - Adjustable fog distance via settings
       ================================================================================================= */
    function updateFog(distance) {
      if (distance > 0) {
        scene.fog = new THREE.Fog(scene.background, distance * 0.35, distance);
      } else {
        scene.fog = null;
      }
    }
    updateFog(700);

    /* =================================================================================================
       Minimap (player tracker), smaller size
       -------------------------------------------------------------------------------------------------
       - Draw chunk grid tiles
       - Draw player position and facing direction
       ================================================================================================= */
    const minimapCanvas = document.getElementById("minimapCanvas");
    const mmCtx = minimapCanvas.getContext("2d");

    function drawMinimap() {
      const show = document.getElementById("minimapToggle").checked;
      document.getElementById("minimap").style.display = show ? "grid" : "none";
      if (!show) return;

      mmCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
      mmCtx.fillStyle = "#0d1420";
      mmCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);

      const scale = minimapCanvas.width / (VIEW_RADIUS * 2 * CHUNK_SIZE + CHUNK_SIZE);
      const cx = Math.floor(player.position.x / CHUNK_SIZE);
      const cz = Math.floor(player.position.z / CHUNK_SIZE);

      mmCtx.strokeStyle = "rgba(255,255,255,0.25)";
      mmCtx.strokeRect(0,0,minimapCanvas.width,minimapCanvas.height);

      // Draw chunk tiles around player
      mmCtx.fillStyle = "rgba(90,160,255,0.20)";
      for (let dx = -VIEW_RADIUS; dx <= VIEW_RADIUS; dx++) {
        for (let dz = -VIEW_RADIUS; dz <= VIEW_RADIUS; dz++) {
          const x = (dx + VIEW_RADIUS) * CHUNK_SIZE * scale;
          const z = (dz + VIEW_RADIUS) * CHUNK_SIZE * scale;
          mmCtx.fillRect(x, z, CHUNK_SIZE * scale, CHUNK_SIZE * scale);
        }
      }

      // Player marker
      mmCtx.fillStyle = "#ff4444";
      const px = (player.position.x - (cx - VIEW_RADIUS) * CHUNK_SIZE) * scale;
      const pz = (player.position.z - (cz - VIEW_RADIUS) * CHUNK_SIZE) * scale;
      mmCtx.beginPath();
      mmCtx.arc(px, pz, 2.5, 0, Math.PI*2);
      mmCtx.fill();

      // Direction arrow (aligned to yaw)
      mmCtx.strokeStyle = "#ff4444";
      mmCtx.beginPath();
      mmCtx.moveTo(px, pz);
      mmCtx.lineTo(px + Math.sin(-yaw) * 10, pz + Math.cos(-yaw) * 10);
      mmCtx.stroke();
    }

    /* =================================================================================================
       Settings bindings (incl. close/open panel button)
       -------------------------------------------------------------------------------------------------
       - Live updates of chunk/view/fog/etc.
       - Toggle shadows and antialias by rebuilding renderer or toggling flags
       ================================================================================================= */
    const viewRadiusSlider = document.getElementById("viewRadiusSlider");
    const viewRadiusLabel  = document.getElementById("viewRadiusLabel");
    const chunkSizeSlider  = document.getElementById("chunkSizeSlider");
    const chunkSizeLabel   = document.getElementById("chunkSizeLabel");
    const heightSlider     = document.getElementById("heightSlider");
    const heightLabel      = document.getElementById("heightLabel");
    const fogSlider        = document.getElementById("fogSlider");
    const fogLabel         = document.getElementById("fogLabel");
    const aaToggle         = document.getElementById("aaToggle");
    const shadowToggle     = document.getElementById("shadowToggle");
    const closePanelBtn    = document.getElementById("closePanelBtn");
    const openPanelBtn     = document.getElementById("openPanelBtn");

    closePanelBtn.addEventListener("click", () => {
      document.getElementById("panel").style.display = "none";
      openPanelBtn.style.display = "inline-block";
      openPanelBtn.style.position = "absolute";
      openPanelBtn.style.left = "12px";
      openPanelBtn.style.bottom = "200px";
    });

    openPanelBtn.addEventListener("click", () => {
      document.getElementById("panel").style.display = "block";
      openPanelBtn.style.display = "none";
    });

    viewRadiusSlider.addEventListener("input", () => {
      VIEW_RADIUS = parseInt(viewRadiusSlider.value, 10);
      viewRadiusLabel.textContent = VIEW_RADIUS.toString();
      lastChunkUpdate = 0;
    });

    chunkSizeSlider.addEventListener("input", () => {
      const newSize = parseInt(chunkSizeSlider.value, 10);
      chunkSizeLabel.textContent = newSize.toString();
      if (newSize !== CHUNK_SIZE) {
        CHUNK_SIZE = newSize;
        // Clear loaded chunks; they'll reload around player on next update
        for (const [ck, data] of chunks) {
          if (data.group) scene.remove(data.group);
          chunks.delete(ck);
        }
        lastChunkUpdate = 0;
      }
    });

    heightSlider.addEventListener("input", () => {
      const newH = parseInt(heightSlider.value, 10);
      heightLabel.textContent = newH.toString();
      MAX_HEIGHT = newH;
      generateTerrain();
      // Rebuild loaded chunks
      const loaded = Array.from(chunks.keys()).map(k => k.split(',').map(Number));
      for (const [cx, cz] of loaded) {
        const ck = chunkKey(cx, cz);
        const cur = chunks.get(ck);
        if (cur && cur.group) scene.remove(cur.group);
        chunks.delete(ck);
        loadChunk(cx, cz);
      }
    });

    fogSlider.addEventListener("input", () => {
      const dist = parseInt(fogSlider.value, 10);
      fogLabel.textContent = dist.toString();
      updateFog(dist);
    });

    aaToggle.addEventListener("change", () => {
      ANTIALIAS = aaToggle.checked;
      renderer.dispose();
      const old = renderer.domElement;
      old.parentNode.removeChild(old);
      const newRenderer = new THREE.WebGLRenderer({ antialias: ANTIALIAS, powerPreference: "high-performance" });
      newRenderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(newRenderer.domElement);
      renderer = newRenderer;
      bindPointerLockMouseMove();
    });

    shadowToggle.addEventListener("change", () => {
      const enable = shadowToggle.checked;
      dir.intensity = enable ? 0.45 : 0.0;
      renderer.shadowMap.enabled = enable;
      player.castShadow = enable;
      player.receiveShadow = false;
      for (const data of chunks.values()) {
        if (!data.meshes) continue;
        for (const mesh of [data.meshes.grass, data.meshes.dirt, data.meshes.stone]) {
          if (mesh) {
            mesh.castShadow = false; // keep off for performance
            mesh.receiveShadow = enable;
          }
        }
      }
    });

    /* =================================================================================================
       Desktop controls and pointer lock (optional)
       -------------------------------------------------------------------------------------------------
       - Map WASD to movement vector for parity with touch movement ring
       - Double-click toggles pointer lock
       ================================================================================================= */
    const keys = new Set();
    window.addEventListener('keydown', e => {
      keys.add(e.code);
      if (e.code === "Space") jumpBtn.click();
    });
    window.addEventListener('keyup', e => keys.delete(e.code));

    let pointerLockEnabled = false;
    function enablePointerLock() {
      const c = renderer.domElement;
      if (c.requestPointerLock) c.requestPointerLock();
    }
    document.addEventListener('pointerlockchange', () => {
      pointerLockEnabled = (document.pointerLockElement === renderer.domElement);
    });

    let lastClick = 0;
    renderer.domElement.addEventListener('click', () => {
      const now = performance.now();
      if (now - lastClick < 300) enablePointerLock();
      lastClick = now;
    });

    function bindPointerLockMouseMove() {
      renderer.domElement.addEventListener('mousemove', e => {
        if (!pointerLockEnabled) return;
        const dx = e.movementX || 0;
        const dy = e.movementY || 0;
        yaw   -= dx * 0.0025;
        pitch -= dy * 0.0025;
        pitch = clamp(pitch, -Math.PI/3, Math.PI/3);
      });
    }
    bindPointerLockMouseMove();

    // Map WASD to movement ring to keep a single pipeline
    function desktopControlsToMoveRing() {
      let x = 0, y = 0; // x=strife, y=forward/back
      if (keys.has("KeyA")) x -= 1;
      if (keys.has("KeyD")) x += 1;
      if (keys.has("KeyW")) y += 1;
      if (keys.has("KeyS")) y -= 1;
      const len = Math.hypot(x, y); if (len > 0) { x /= len; y /= len; }
      moveInput.x = x; moveInput.y = y;
      const dx = x * moveRadiusPx;
      const dy = -y * moveRadiusPx; // invert visual Y to match screen orientation
      setPuck(movePuck, moveCenter.x, moveCenter.y, dx, dy, moveRadiusPx);
      requestAnimationFrame(desktopControlsToMoveRing);
    }
    desktopControlsToMoveRing();

    /* =================================================================================================
       Main loop: physics, chunk updates, movement, camera, render
       -------------------------------------------------------------------------------------------------
       - The critical spot where joystick values are consumed:
         moveInput drives movement; lookInput drives yaw/pitch
       ================================================================================================= */
    let lastTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);
      const now = performance.now();
      dtGlobal = Math.min((now - lastTime) / 1000, 0.033);
      lastTime = now;

      // Keep nearby chunks loaded (throttled)
      updateVisibleChunks(player.position.x, player.position.z, now);

      // Gravity and vertical motion
      playerVel.y -= GRAVITY * dtGlobal;
      groundSnapAndDetect(dtGlobal);

      // Movement relative to rotation (forward/back/strafe aligned with yaw)
      const { forward, right } = getFacingVectors();
      const moveDir = new THREE.Vector3()
        .addScaledVector(forward, moveInput.y)   // <-- use moveInput.y (forward/back)
        .addScaledVector(right,   moveInput.x);  // <-- use moveInput.x (strafe)
      if (moveDir.lengthSq() > 0) moveDir.normalize();

      const vx = moveDir.x * MOVE_SPEED;
      const vz = moveDir.z * MOVE_SPEED;

      // Horizontal separation: resolve X then Z axis to avoid jitter
      player.position.x += vx * dtGlobal;
      horizontalResolve('x');

      player.position.z += vz * dtGlobal;
      horizontalResolve('z');

      // Floor safety and bounds
      player.position.x = clamp(player.position.x, capsuleRadius, WORLD_SIZE - capsuleRadius);
      player.position.z = clamp(player.position.z, capsuleRadius, WORLD_SIZE - capsuleRadius);
      if (player.position.y < capsuleHeight / 2) {
        player.position.y = capsuleHeight / 2;
        playerVel.y = 0;
        onGround = true;
      }

      // Camera, minimap, render
      updateCamera();
      drawMinimap();
      renderer.render(scene, camera);
    }
    animate();

    /* =================================================================================================
       Resize handler
       -------------------------------------------------------------------------------------------------
       - Keep aspect ratio and renderer size in sync
       - Recompute joystick centers
       ================================================================================================= */
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      recalcCenters();
    });

    /* =================================================================================================
       Initial chunk preload around player for fast first frame
       -------------------------------------------------------------------------------------------------
       - Load chunks in the view radius immediately
       ================================================================================================= */
    (function preloadInitial() {
      const cx = Math.floor(player.position.x / CHUNK_SIZE);
      const cz = Math.floor(player.position.z / CHUNK_SIZE);
      const maxCx = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;
      const maxCz = Math.ceil(WORLD_SIZE / CHUNK_SIZE) - 1;
      for (let dx = -VIEW_RADIUS; dx <= VIEW_RADIUS; dx++) {
        for (let dz = -VIEW_RADIUS; dz <= VIEW_RADIUS; dz++) {
          const ncx = cx + dx, ncz = cz + dz;
          if (ncx < 0 || ncz < 0 || ncx > maxCx || ncz > maxCz) continue;
          loadChunk(ncx, ncz);
        }
      }
    })();
  </script>
</body>
</html>
