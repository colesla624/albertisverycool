<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Builder Game</title>
    <!-- Load Tailwind CSS for easy UI styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering (r128 is stable and compatible with custom capsule implementation) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Custom CSS for the canvas and overall layout */
        body { margin: 0; overflow: hidden; background-color: #1a1a2e; font-family: 'Inter', sans-serif; }
        canvas { display: block; }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Prevents default browser touch actions */
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            margin: -5px 0 0 -5px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }

        /* Action button refinement */
        .action-btn {
            @apply shadow-2xl transition transform active:scale-95 text-white font-bold rounded-full;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.6));
            -webkit-tap-highlight-color: transparent;
        }

        /* Fixed Joystick Base Styles */
        #joystick-base {
            position: absolute;
            bottom: 30px; 
            left: 30px; 
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            z-index: 50;
            opacity: 0.8; 
        }

        /* Joystick Handle Styles (will move) */
        #joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.9);
            z-index: 60;
            opacity: 0; 
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- 3D Canvas will be injected here -->
        <div id="crosshair"></div>

        <!-- Inventory/HUD -->
        <div id="hud" class="absolute top-4 left-1/2 transform -translate-x-1/2 p-2 bg-gray-900 bg-opacity-70 rounded-xl shadow-lg z-20 flex space-x-4">
            <div id="active-block" class="p-2 border-2 border-green-400 rounded-lg text-white font-bold cursor-pointer hover:bg-gray-700 transition">
                Active: Wood
            </div>
            <div id="action-tip" class="p-2 text-sm text-gray-300 hidden sm:block">
                WASD/Arrows to Move | Click to Lock Mouse & Look | Right-Click to Place
            </div>
        </div>
        
        <!-- View Toggle Button (New!) -->
        <button id="view-toggle-btn" class="absolute top-4 right-4 action-btn bg-purple-500 hover:bg-purple-600 active:bg-purple-700 p-3 text-sm z-30 w-32 h-12">
            Toggle View (FP)
        </button>


        <!-- Fixed Joystick Base (Now always visible) -->
        <div id="joystick-base"></div>
        <!-- Dynamic Joystick Handle (Now always available) -->
        <div id="joystick-handle"></div>

        <!-- Mobile Action Buttons (Right Side, now always visible) -->
        <div id="action-buttons" class="absolute bottom-6 right-6 flex flex-col space-y-4 z-20">
            <!-- Jump Button -->
            <button id="jump-btn" class="action-btn w-16 h-16 bg-blue-500 hover:bg-blue-600 active:bg-blue-700 text-3xl">
                â†‘
            </button>
            <!-- Place Block -->
            <button id="place-btn" class="action-btn w-16 h-16 bg-green-500 hover:bg-green-600 active:bg-green-700 text-4xl">
                +
            </button>
            <!-- Mine Block -->
            <button id="mine-btn" class="action-btn w-16 h-16 bg-red-500 hover:bg-red-600 active:bg-red-700 text-4xl">
                -
            </button>
        </div>

    </div>

    <script type="module">
        // Global Three.js variables
        let scene, camera, renderer;
        
        // Player visualization model
        let playerModel; 
        
        let controls = { 
            forward: 0, 
            backward: 0, 
            left: 0, 
            right: 0, 
            up: false, 
            down: false 
        };
        
        // Player state object to hold position and rotation
        const player = {
            position: new THREE.Vector3(0, 5, 0),
            // Player rotation is only for the direction of movement (Y-axis)
            rotationY: 0, 
        };
        
        // Camera state for TP orbiting
        let isThirdPerson = false;
        const thirdPersonDistance = 3.5; 
        const thirdPersonHeightOffset = 1.0; 
        
        // Camera look angles (used for both FP and TP look control)
        const cameraLook = {
            yaw: 0, // Y-axis rotation (horizontal)
            pitch: 0, // X-axis rotation (vertical)
        };
        
        // Joystick state (now fixed position)
        const joystick = {
            active: false,
            touchId: null,
            base: document.getElementById('joystick-base'),
            handle: document.getElementById('joystick-handle'),
            baseX: 0, 
            baseY: 0,
            radius: 60, 
            maxDistance: 40 
        };

        // State tracker for the camera 'look' touch interaction
        let activeLookTouch = null; 

        const blockMap = new Map();
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 10);
        const playerSpeed = 0.08;
        const lookSpeed = 0.003; 
        const blockTypes = {
            GRASS: { name: 'Grass', color: 0x4CAF50, geometry: new THREE.BoxGeometry(1, 1, 1), material: new THREE.MeshLambertMaterial({ color: 0x4CAF50 }) },
            DIRT: { name: 'Dirt', color: 0x795548, geometry: new THREE.BoxGeometry(1, 1, 1), material: new THREE.MeshLambertMaterial({ color: 0x795548 }) },
            STONE: { name: 'Stone', color: 0x78909C, geometry: new THREE.BoxGeometry(1, 1, 1), material: new THREE.MeshLambertMaterial({ color: 0x78909C }) },
            WOOD: { name: 'Wood', color: 0x8D6E63, geometry: new THREE.BoxGeometry(1, 1, 1), material: new THREE.MeshLambertMaterial({ color: 0x8D6E63 }) },
        };
        let activeBlockType = blockTypes.WOOD;

        /**
         * Converts coordinates to a unique string key.
         */
        function getKey(x, y, z) {
            return `${x},${y},${z}`;
        }
        
        /**
         * Custom function to create a capsule geometry by combining a cylinder and two hemispheres (spheres).
         * This ensures compatibility with older Three.js versions like r128 which lack THREE.CapsuleGeometry.
         * Returns a THREE.Group representing the capsule.
         */
        function createCapsuleGeometry(radius, height, radialSegments, heightSegments) {
            const cylinderHeight = height - (2 * radius);
            
            // 1. Create Cylinder
            const cylinder = new THREE.CylinderGeometry(
                radius, radius, cylinderHeight, radialSegments, heightSegments
            );
            const cylinderMesh = new THREE.Mesh(cylinder);
            
            // 2. Top Sphere (Hemisphere equivalent)
            const topMesh = new THREE.Mesh(new THREE.SphereGeometry(radius, radialSegments, radialSegments / 2));
            topMesh.position.y = cylinderHeight / 2;

            // 3. Bottom Sphere (Hemisphere equivalent)
            const bottomMesh = new THREE.Mesh(new THREE.SphereGeometry(radius, radialSegments, radialSegments / 2));
            bottomMesh.position.y = -cylinderHeight / 2;
            
            const group = new THREE.Group();
            group.add(cylinderMesh, topMesh, bottomMesh);
            return group; 
        }


        /**
         * Creates and initializes the player visualization model.
         */
        function createPlayerModel() {
            const radius = 0.3;
            const height = 1.8;
            const segments = 16;
            
            // Create the composite capsule model (Group)
            const playerModelGroup = createCapsuleGeometry(radius, height, segments, 1);
            
            const material = new THREE.MeshStandardMaterial({ color: 0x33AFFF });
            
            // Apply the material to all parts of the group
            playerModelGroup.traverse((child) => {
                if (child.isMesh) {
                    child.material = material;
                    // Center the entire visual model group at Y=0 relative to the player.position (head height)
                    child.position.y += (height / 2) - radius; 
                }
            });

            // Player model group handles the position and overall rotation
            playerModel = new THREE.Group();
            playerModel.add(playerModelGroup);
            
            // Final position is set in init() and animate()
            playerModel.position.copy(player.position);
            playerModel.visible = isThirdPerson; // Start hidden (FP)
            scene.add(playerModel);
        }

        /**
         * Calculates the fixed position of the joystick base center.
         */
        function calculateJoystickPosition() {
            const rect = joystick.base.getBoundingClientRect();
            joystick.baseX = rect.left + joystick.radius;
            joystick.baseY = rect.top + joystick.radius;

            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;
        }

        /**
         * Initializes the 3D environment, scene, camera, and world.
         */
        function init() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;
            const aspectRatio = containerWidth / containerHeight;

            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 

            // 2. Camera Setup
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.copy(player.position); 

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerWidth, containerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement); 

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 3); 
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // 5. Player Model and World
            createPlayerModel();
            generateWorld(16, 6);

            // 6. Event Listeners
            window.addEventListener('resize', () => {
                onWindowResize();
                calculateJoystickPosition(); 
            });
            setupInputListeners(container);

            calculateJoystickPosition(); 
            updateActiveBlockDisplay();

            // 7. Start the game loop
            animate();
        }

        /**
         * Generates a basic voxel world. 
         */
        function generateWorld(size, layers) {
            const offset = Math.floor(size / 2);
            for (let x = -offset; x <= offset; x++) {
                for (let z = -offset; z <= offset; z++) {
                    for (let y = 0; y < layers; y++) {
                        let type;
                        if (y === layers - 1) {
                            type = blockTypes.GRASS;
                        } else if (y >= layers - 3) {
                            type = blockTypes.DIRT;
                        } else {
                            type = blockTypes.STONE;
                        }
                        addBlock(x, y, z, type);
                    }
                }
            }
        }

        /**
         * Adds a block mesh to the scene and the block map. 
         */
        function addBlock(x, y, z, type) {
            const mesh = new THREE.Mesh(type.geometry, type.material);
            mesh.position.set(x + 0.5, y + 0.5, z + 0.5); 
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.userData = { isBlock: true, type: type.name }; 
            scene.add(mesh);
            blockMap.set(getKey(x, y, z), mesh);
        }

        /**
         * Removes a block mesh from the scene and the block map. 
         */
        function removeBlock(x, y, z) {
            const key = getKey(x, y, z);
            const mesh = blockMap.get(key);
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
                blockMap.delete(key);
            }
        }

        /**
         * Raycasts from the camera to find the targeted block. 
         */
        function getTargetedBlock() {
            // Raycast direction is always forward from the camera's current rotation/view
            raycaster.setFromCamera({ x: 0, y: 0 }, camera); 
            const intersects = raycaster.intersectObjects(scene.children.filter(obj => obj.userData.isBlock));

            if (intersects.length > 0) {
                const intersect = intersects[0];
                const blockMesh = intersect.object;
                const x = Math.floor(blockMesh.position.x - 0.5);
                const y = Math.floor(blockMesh.position.y - 0.5);
                const z = Math.floor(blockMesh.position.z - 0.5);
                const normal = intersect.face.normal.clone();

                return { x, y, z, normal };
            }
            return null;
        }

        /**
         * Mines (removes) the targeted block. 
         */
        function mineBlock() {
            const target = getTargetedBlock();
            if (target) {
                removeBlock(target.x, target.y, target.z);
            }
        }

        /**
         * Places the active block adjacent to the targeted block. 
         */
        function placeBlock() {
            const target = getTargetedBlock();
            if (target) {
                const newX = target.x + Math.round(target.normal.x);
                const newY = target.y + Math.round(target.normal.y);
                const newZ = target.z + Math.round(target.normal.z);

                const playerBlockX = Math.floor(player.position.x);
                const playerBlockYHead = Math.floor(player.position.y);
                const playerBlockYFeet = Math.floor(player.position.y - 1.5);

                const newBlockKey = getKey(newX, newY, newZ);
                
                // Check collision with player's head block and feet block
                if (
                    (newBlockKey !== getKey(playerBlockX, playerBlockYHead, Math.floor(player.position.z))) &&
                    (newBlockKey !== getKey(playerBlockX, playerBlockYFeet, Math.floor(player.position.z))) &&
                    !blockMap.has(newBlockKey)
                ) {
                    addBlock(newX, newY, newZ, activeBlockType);
                }
            }
        }

        /**
         * Handles the main game loop and updates. 
         */
        function animate() {
            requestAnimationFrame(animate);

            // 1. Player Movement Update
            const movementApplied = controls.forward > 0 || controls.backward > 0 || controls.left > 0 || controls.right > 0;
            
            // Get the direction the camera is looking (for TP movement)
            const cameraDirection = new THREE.Vector3(0, 0, -1).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            cameraDirection.y = 0;
            cameraDirection.normalize();

            // Calculate the right vector perpendicular to the camera's horizontal view
            const rightVector = new THREE.Vector3(1, 0, 0).applyEuler(new THREE.Euler(0, cameraLook.yaw, 0, 'YXZ'));
            rightVector.y = 0;
            rightVector.normalize();

            // Apply movement to player.position
            if (controls.forward > 0) player.position.addScaledVector(cameraDirection, playerSpeed * controls.forward);
            if (controls.backward > 0) player.position.addScaledVector(cameraDirection, -playerSpeed * controls.backward);
            if (controls.right > 0) player.position.addScaledVector(rightVector, playerSpeed * controls.right);
            if (controls.left > 0) player.position.addScaledVector(rightVector, -playerSpeed * controls.left);

            // Update player Y rotation to face the direction of movement (TP aesthetics)
            if (movementApplied) {
                // If moving, calculate the desired forward vector from controls
                const desiredDirection = new THREE.Vector3(0, 0, 0);
                desiredDirection.addScaledVector(cameraDirection, controls.forward - controls.backward);
                desiredDirection.addScaledVector(rightVector, controls.right - controls.left);
                
                if (desiredDirection.lengthSq() > 0) {
                    desiredDirection.normalize();
                    // Calculate the angle to face the direction of movement
                    const angle = Math.atan2(desiredDirection.x, desiredDirection.z);
                    player.rotationY = angle;
                }
            }
            
            // Jump/Up movement
            if (controls.up) player.position.y += playerSpeed * 2; 

            // Update Player Model position and rotation
            playerModel.position.copy(player.position);
            playerModel.rotation.y = player.rotationY; // Only rotate yaw for visible player model

            // 2. Camera View Update
            if (isThirdPerson) {
                // Calculate camera position based on yaw and pitch
                const radius = thirdPersonDistance;
                
                // Yaw is horizontal orbit, Pitch is vertical angle (clamped)
                const pitch = cameraLook.pitch;
                const yaw = cameraLook.yaw;
                
                // Spherical coordinates calculation
                camera.position.x = player.position.x + radius * Math.sin(yaw) * Math.cos(pitch);
                camera.position.y = player.position.y + thirdPersonHeightOffset + radius * Math.sin(pitch);
                camera.position.z = player.position.z + radius * Math.cos(yaw) * Math.cos(pitch);
                
                // Camera always looks at the player's center mass
                const targetPoint = player.position.clone().y += thirdPersonHeightOffset;
                camera.lookAt(player.position.x, player.position.y + thirdPersonHeightOffset, player.position.z);
                
            } else {
                // First Person: Camera position and rotation follow player's state exactly
                camera.position.copy(player.position);
                camera.rotation.set(cameraLook.pitch, cameraLook.yaw, 0, 'YXZ');
            }

            // 3. Rendering
            renderer.render(scene, camera);
        }

        /**
         * Toggles between first-person and third-person view.
         */
        function toggleView() {
            isThirdPerson = !isThirdPerson;
            const button = document.getElementById('view-toggle-btn');
            const crosshair = document.getElementById('crosshair');
            
            playerModel.visible = isThirdPerson;
            
            if (isThirdPerson) {
                button.textContent = 'Toggle View (TP)';
                crosshair.style.display = 'none'; 
                // When entering TP, reset player rotation to match current camera yaw
                // This ensures the player is facing where the camera is looking horizontally
                player.rotationY = cameraLook.yaw; 
            } else {
                button.textContent = 'Toggle View (FP)';
                crosshair.style.display = 'block';
                // When entering FP, the camera rotation (yaw/pitch) is already stored in cameraLook
            }
        }
        
        /**
         * Handles window resize for responsiveness. 
         */
        function onWindowResize() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth || window.innerWidth;
            const containerHeight = container.clientHeight || window.innerHeight;

            camera.aspect = containerWidth / containerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(containerWidth, containerHeight);
        }

        /**
         * Updates the position of the visual joystick handle and sets movement controls.
         */
        function updateJoystick(currentX, currentY) {
            const dx = currentX - joystick.baseX;
            const dy = currentY - joystick.baseY;
            let distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let finalX = currentX;
            let finalY = currentY;

            if (distance > joystick.maxDistance) {
                distance = joystick.maxDistance;
                finalX = joystick.baseX + Math.cos(angle) * joystick.maxDistance;
                finalY = joystick.baseY + Math.sin(angle) * joystick.maxDistance;
            } else {
                finalX = currentX;
                finalY = currentY;
            }

            joystick.handle.style.left = `${finalX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${finalY - joystick.radius / 2}px`;

            // Update movement controls magnitude
            const magnitude = distance / joystick.maxDistance; 
            const forwardComponent = -Math.sin(angle); 
            const rightComponent = Math.cos(angle); 

            controls.forward = Math.max(0, forwardComponent) * magnitude;
            controls.backward = Math.max(0, -forwardComponent) * magnitude;
            controls.right = Math.max(0, rightComponent) * magnitude;
            controls.left = Math.max(0, -rightComponent) * magnitude;
        }

        /**
         * Resets the visual joystick and movement controls.
         */
        function resetJoystick() {
            joystick.active = false;
            joystick.touchId = null;
            joystick.handle.style.opacity = '0';
            
            joystick.handle.style.left = `${joystick.baseX - joystick.radius / 2}px`;
            joystick.handle.style.top = `${joystick.baseY - joystick.radius / 2}px`;

            controls.forward = controls.backward = controls.left = controls.right = 0;
        }

        /**
         * Applies rotation changes to the cameraLook state.
         */
        function applyLookDelta(deltaX, deltaY, speed) {
            cameraLook.yaw -= deltaX * speed;
            cameraLook.pitch -= deltaY * speed;
            
            // Clamp pitch (vertical look) to prevent camera flipping
            cameraLook.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraLook.pitch));
        }


        /**
         * Sets up all keyboard and mobile/touch input listeners.
         */
        function setupInputListeners(container) {
            const canvasElement = renderer.domElement;
            const containerWidth = container.clientWidth;

            // --- Keyboard Controls (Desktop) ---
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') controls.forward = 1;
                if (key === 's' || key === 'arrowdown') controls.backward = 1;
                if (key === 'a' || key === 'arrowleft') controls.left = 1;
                if (key === 'd' || key === 'arrowright') controls.right = 1;
                if (key === ' ') controls.up = true; 
                if (key === 'shift') controls.down = true; 
                if (key === 'v') toggleView(); 
            });

            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                if (key === 'w' || key === 'arrowup') controls.forward = 0;
                if (key === 's' || key === 'arrowdown') controls.backward = 0;
                if (key === 'a' || key === 'arrowleft') controls.left = 0;
                if (key === 'd' || key === 'arrowright') controls.right = 0;
                if (key === ' ') controls.up = false;
                if (key === 'shift') controls.down = false;
            });

            // --- Mouse/Look & Action Controls (Desktop) ---
            canvasElement.addEventListener('mousedown', (e) => {
                if (e.pointerType === 'mouse' || container.clientWidth > 768) { 
                    if (e.button === 0) {
                        mineBlock();
                        if (canvasElement.requestPointerLock) {
                            canvasElement.requestPointerLock();
                        }
                    } 
                    else if (e.button === 2) {
                        placeBlock(); 
                    }
                }
            });
            
            canvasElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === canvasElement) { 
                    applyLookDelta(e.movementX, e.movementY, lookSpeed);
                }
            });

            // --- Mobile Touch Controls (Joystick & Look Pad) ---
            
            const isInsideJoystickArea = (clientX, clientY) => {
                const dx = clientX - joystick.baseX;
                const dy = clientY - joystick.baseY;
                return Math.sqrt(dx * dx + dy * dy) <= joystick.radius;
            };

            container.addEventListener('touchstart', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (!joystick.active && isInsideJoystickArea(touch.clientX, touch.clientY)) {
                        // 1. Joystick Activation (Left Side)
                        joystick.active = true;
                        joystick.touchId = touch.identifier;
                        joystick.handle.style.opacity = '1';
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    else if (
                        // 2. Look Pad Activation (Right Half)
                        touch.clientX >= containerWidth / 2 && 
                        !touch.target.closest('#action-buttons') && 
                        !activeLookTouch &&
                        !touch.target.closest('#view-toggle-btn')
                    ) {
                        activeLookTouch = {
                            identifier: touch.identifier,
                            prevX: touch.clientX,
                            prevY: touch.clientY
                        };
                    }
                }
            }, { passive: true }); 

            container.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    // 1. Joystick Movement 
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        updateJoystick(touch.clientX, touch.clientY);
                    } 
                    
                    // 2. Camera Look (Right Half)
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        const deltaX = touch.clientX - activeLookTouch.prevX;
                        const deltaY = touch.clientY - activeLookTouch.prevY;
                        
                        // Use a 5x multiplier for touch responsiveness
                        applyLookDelta(deltaX, deltaY, lookSpeed * 5); 
                        
                        activeLookTouch.prevX = touch.clientX; 
                        activeLookTouch.prevY = touch.clientY;
                    }
                }
            }, { passive: false }); 

            container.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    
                    if (joystick.active && touch.identifier === joystick.touchId) {
                        resetJoystick();
                    }
                    
                    if (activeLookTouch && touch.identifier === activeLookTouch.identifier) {
                        activeLookTouch = null;
                    }
                }
            }, { passive: true });
            
            // --- Mobile Action Button Listeners ---
            document.getElementById('mine-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                mineBlock();
            }, { passive: false });

            document.getElementById('place-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                placeBlock();
            }, { passive: false });
            
            document.getElementById('jump-btn').addEventListener('pointerdown', (e) => {
                e.preventDefault();
                controls.up = true; 
            }, { passive: false });
            document.getElementById('jump-btn').addEventListener('pointerup', (e) => {
                e.preventDefault();
                controls.up = false; 
            }, { passive: false });

            // --- View Toggle Button Listener ---
            document.getElementById('view-toggle-btn').addEventListener('click', toggleView);


            // --- Block Selection (Simple cycling through available types) ---
            document.getElementById('active-block').addEventListener('click', cycleActiveBlock);
        }

        /**
         * Cycles the active block type for placing. 
         */
        function cycleActiveBlock() {
            const typesArray = Object.values(blockTypes);
            let currentIndex = typesArray.findIndex(type => type.name === activeBlockType.name);
            currentIndex = (currentIndex + 1) % typesArray.length;
            activeBlockType = typesArray[currentIndex];
            updateActiveBlockDisplay();
        }

        /**
         * Updates the HUD to show the currently selected block. 
         */
        function updateActiveBlockDisplay() {
            const display = document.getElementById('active-block');
            display.textContent = `Active: ${activeBlockType.name}`;
            display.style.borderColor = `#${activeBlockType.color.toString(16).padStart(6, '0')}`;
        }


        // Start the application after the window loads
        window.onload = init;
    </script>
</body>
</html>
